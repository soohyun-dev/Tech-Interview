# 23년 3월 첫째주 Weekly Study

<br>

## 📜 목차

### cs

- 브라우저 주소창에 www.google.com을 입력하면 어떤 일이 일어나나요?
- DNS에 대해 설명해주세요.
- GET과 POST의 차이는 무엇인가요?
- REST API에 대해 설명해주세요.

<br>

### javascript + html + css

- Promise와 Callback 차이를 설명해주세요.
- 콜백 지옥(Callback hell)을 해결하는 방법을 말씀해주세요.
- Flexbox를 사용해보셨나요?
- Cascading에 관해서 설명해주세요.

<br>

### react + redux

- Virtual DOM 작동 원리에 대해 설명해주세요.
- Virtual DOM 이 무엇인지 설명해주세요.
- Redux를 사용하는 이유가 무엇인가요?
- Redux의 장단점에 대해 설명해주세요.

<br>

### frontend

- 브라우저 렌더링 과정을 설명해주세요.
- 브라우저는 어떻게 동작 하나요?
- Webpack, Babel, Polyfill에 대해 설명해주세요.
- CSR과 SSR의 차이는 무엇인가요?

<br>

### 기타(인성 면접)

- 회사 지원 동기를 말씀해주세요.
- 최근 경험했던 기억에 남는 에러에 대해 말씀해주세요.
- 요즘 공부하고 있는 것을 말씀해주세요.
- 자바스크립트를 공부하면서 가장 인상 깊었던 것을 말씀해주세요.

<br>

## 📌 1. 브라우저 주소창에 www.google.com을 입력하면 어떤 일이 일어나나요?

1. 사용자가 웹 브라우저를 통해 google.com 을 입력하면 URL 주소 중 도메인 네임 부분을 DNS 서버에서 검색합니다.
2. DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달합니다.
3. 브라우저는 HTTP 프로토콜을 사용하여 요청 메시지를 생성하고 HTTP 요청 메시지는 TCP/IP 프로토콜을 사용하여 서버로 전송됩니다.
4. 서버는 response 메시지를 생성하여 다시 브라우저에게 데이터를 전송합니다.
5. 브라우저는 response를 받아 파싱하여 화면에 렌더링합니다.

<br>

1. 브라우저는 입력된 주소를 파싱하여 프로토콜(여기서는 HTTP), 호스트명(www.google.com) 등으로 나눕니다.
2. 브라우저는 호스트명을 IP 주소로 변환하기 위해 DNS(Domain Name System) 서버에 요청을 보냅니다.
3. DNS 서버는 호스트명을 IP 주소로 변환하여 브라우저에 응답합니다.
4. 브라우저는 변환된 IP 주소를 사용하여 HTTP 요청 메시지를 생성하고 서버에 보냅니다.
5. 서버는 요청을 받아 구글 홈페이지를 포함한 해당 웹 페이지에 필요한 리소스를 브라우저에 응답합니다.
6. 브라우저는 응답된 리소스(HTML, CSS, JavaScript, 이미지 등)를 다운로드하고 렌더링 엔진(Rendering Engine)을 사용하여 페이지를 렌더링합니다.
7. 페이지의 렌더링이 완료되면 브라우저는 해당 페이지를 표시합니다.

이러한 과정을 통해 브라우저는 사용자가 입력한 www.google.com 주소에 해당하는 구글 홈페이지를 로드하고 보여줍니다.

<br>

## 📌 2. DNS에 대해 설명해주세요.

DNS는 Domain Name System의 약자로, 인터넷에서 사용되는 주소를 숫자로 된 IP 주소에서 사람이 이해하기 쉬운 도메인 이름으로 변환해주는 시스템입니다.

인터넷에 연결된 기기는 모두 IP 주소를 사용하여 통신을 합니다. 하지만 IP 주소는 일반 사용자가 기억하기 어렵고, 주소를 입력하기에도 불편합니다. 따라서 DNS는 도메인 이름과 IP 주소를 매핑하는 역할을 하여, 도메인 이름을 입력하면 해당 도메인 이름에 대한 IP 주소를 찾아서 사용자 기기로 전달해주는 역할을 합니다.

DNS는 계층 구조를 가지고 있으며, 이를 DNS 트리라고 부릅니다. 최상위에는 루트 DNS 서버가 있으며, 그 하위에는 최상위 도메인(.com, .net, .org 등)의 DNS 서버, 그리고 그 다음 하위 도메인의 DNS 서버와 계속하여 하위 도메인의 DNS 서버로 이어집니다.

DNS 서버는 일반적으로 ISP(Internet Service Provider)나 공공 DNS 서비스 업체가 운영합니다. 사용자가 도메인 이름을 입력하면, 우선 자신의 컴퓨터나 라우터에 캐시된 DNS 정보를 확인하고, 없을 경우에는 DNS 서버에 질의하여 IP 주소를 받아옵니다.

<br>

## 📌 3. GET과 POST의 차이는 무엇인가요?

GET과 POST는 HTTP(Hypertext Transfer Protocol) 요청 방식 중에서 가장 많이 사용되는 두 가지 방식입니다.

이 둘의 가장 큰 차이점은 데이터를 전송하는 방식과 목적에 있습니다.

GET 방식은 서버로부터 데이터를 요청할 때 사용되며, 요청하는 데이터를 URL에 포함하여 전송합니다.

예를 들어, 웹 브라우저에서 구글 검색창에 검색어를 입력하면, 검색어가 URL의 쿼리 스트링에 포함되어 GET 요청으로 전송됩니다.

이 방식은 URL에 요청 정보를 모두 포함하기 때문에, 요청을 처리하는 서버나 네트워크에서 쉽게 볼 수 있고, 캐싱이 가능합니다.

하지만 보안상 취약점이 존재할 수 있으며, 전송할 수 있는 데이터 크기가 제한적입니다.

반면 POST 방식은 서버에 데이터를 전송할 때 사용되며, 요청하는 데이터를 HTTP 본문에 포함하여 전송합니다.

예를 들어, 회원가입 폼을 작성하고 제출할 때, 입력한 데이터는 POST 요청으로 전송됩니다.

이 방식은 URL에 데이터가 노출되지 않기 때문에 보안성이 높으며, 전송할 수 있는 데이터 크기도 무제한입니다.

하지만, 캐싱이 불가능하기 때문에 GET 방식보다는 느리고, 보안상 취약점이 존재할 수 있습니다.

따라서, GET 방식은 정보를 가져오는 용도로 사용되며, POST 방식은 정보를 서버에 전송하거나 수정하는 용도로 사용됩니다.

보안이 중요한 데이터 전송이나, 대량의 데이터를 전송해야 할 때는 POST 방식을 사용하는 것이 좋습니다.
<br>

## 📌 4. REST API에 대해 설명해주세요.

REST API는 Representational State Transfer(표현 상태 전이)의 약자로, 웹 상에서 서로 다른 시스템 간에 상호작용하는데 사용되는 아키텍처 스타일입니다.

REST API를 통해 클라이언트는 서버에 데이터를 요청하거나 수정, 삭제할 수 있습니다.

REST API는 자원, HTTP 메서드, 표현 방식, 상태 코드 등으로 구성됩니다.

자원은 URI(Uniform Resource Identifier)로 표현되며, HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 자원에 대한 요청을 수행합니다.

표현 방식은 클라이언트와 서버 간의 데이터 전송 방식으로, 일반적으로 JSON, XML 등이 사용됩니다.

상태 코드는 서버가 요청을 처리한 후 응답 상태를 나타내는 코드입니다.

REST의 기본 원칙을 성실히 지킨 서비스 디자인을 `RESTful`이라고 표현한다.

<br>

REST API의 장점은 다음과 같습니다.

높은 확장성: REST API는 URI를 통해 자원을 표현하기 때문에, 다양한 시스템에서 사용하기 쉽습니다.

높은 호환성: REST API는 HTTP 프로토콜을 사용하므로, 다양한 클라이언트와 서버 간에 상호작용할 수 있습니다.

간결하고 가독성이 높음: REST API는 자원, HTTP 메서드, 표현 방식, 상태 코드 등으로 구성되어 있어서, 이해하기 쉽고 가독성이 높습니다.

캐싱 가능: REST API는 HTTP 프로토콜을 사용하므로, 캐싱이 가능하며, 네트워크 대역폭을 절약할 수 있습니다.

분리된 클라이언트-서버 구조: REST API는 클라이언트와 서버가 분리되어 있기 때문에, 각각의 시스템을 독립적으로 개발할 수 있습니다.

<br>

## 📌 5. Promise와 Callback 차이를 설명해주세요.

자바스크립트에서는 비동기 처리를 위한 패턴중 하나로 콜백 함수를 사용합니다.

전통적인 콜백 패턴은 '콜백 헬'로 인해 가독성이 나쁘고 비동기 처리 중 발생한 에러의 처리가 곤란하며 여러 개의 비동기 처리를 한 번에 처리하는데 한계가 있습니다.

ES6에서 도입된 프로미스는, 이러한 콜백 함수의 문제점인 비동기 처리를 해결하기 위한 또 하나의 패턴입니다.

프로미스는 호스트 객체가 아닌 ECMAScript 사양에 정의된 표준 빌트인 객체입니다.

Promise 객체는 비동기 작업의 성공과 실패를 처리하는 콜백 함수를 등록할 수 있습니다.

Promise 객체는 성공 시 resolve 콜백 함수와 실패 시 reject 콜백 함수를 등록할 수 있습니다.

콜백 함수는 작업이 완료될 때마다 매번 호출되며, 이는 코드의 가독성을 해치고 디버깅이 어렵게 만들 수 있습니다.

반면, Promise는 비동기 작업의 결과에 대한 콜백 함수를 한 번만 등록하므로 코드의 가독성이 높아지고, 디버깅이 쉬워집니다.

또한, 여러 개의 비동기 작업을 순차적으로 실행해야 하는 경우, 콜백 함수를 사용하면 콜백 지옥(Callback Hell)이라는 코드의 중첩이 깊어지는 문제가 발생할 수 있습니다.

이를 해결하기 위해 Promise 객체를 사용하면 비동기 작업을 체인 형태로 실행할 수 있어 가독성이 높아집니다.

따라서, Promise는 코드의 가독성이 좋고 디버깅이 쉬우며, 콜백 지옥 문제를 해결하기 위한 좋은 대안입니다.

<br>

## 📌 6. 콜백 지옥(Callback hell)을 해결하는 방법을 말씀해주세요.

콜백 지옥(Callback hell)은 콜백 함수를 계속 중첩해서 사용하는 코드 구조로, 가독성과 유지보수성이 떨어지는 문제를 일으킵니다. 이를 해결하는 방법으로는 아래와 같은 방법들이 있습니다.

1. 프로미스(Promise) 사용

프로미스는 비동기 작업의 결과를 나타내는 객체로, 콜백 함수 대신 프로미스 객체를 반환받아 then() 메서드로 연결하여 비동기 작업을 순차적으로 처리할 수 있습니다.

또한, catch() 메서드로 예외 처리도 가능합니다.

2. async/await 사용

async/await는 프로미스를 더욱 쉽게 사용할 수 있도록 해주는 구문입니다.

async 함수 내에서 await 키워드를 사용하여 비동기 작업을 처리하면, 해당 작업이 완료될 때까지 함수가 일시 중지되고, 작업이 완료되면 결과를 반환합니다.

3. 콜백 함수 분리

콜백 함수를 익명 함수로 중첩하지 않고, 함수를 분리하여 코드를 작성하는 것도 좋은 방법입니다.

이를 통해 가독성과 유지보수성을 높일 수 있습니다.

4. 라이브러리 사용

콜백 지옥을 해결하기 위한 다양한 라이브러리들이 존재합니다.

대표적으로는 async, Bluebird, Q 등이 있습니다. 이러한 라이브러리를 사용하여 비동기 작업을 간편하게 처리할 수 있습니다.

<br>

## 📌 7. Flexbox를 사용해보셨나요?

lexbox는 CSS3에서 도입된 레이아웃 모듈 중 하나로, 요소들을 간단하게 배치하기 위한 방법을 제공합니다.

Flexbox는 수직, 수평 중심으로 요소를 배치할 수 있고, 요소들의 크기를 유동적으로 조절하여 레이아웃을 구성할 수 있습니다.

Flexbox의 주요 개념 중 하나는 플렉스 컨테이너와 플렉스 아이템입니다.

플렉스 컨테이너는 요소들을 감싸는 부모 요소이며, display: flex 속성을 이용하여 설정합니다.

플렉스 아이템은 컨테이너 안에 있는 각 요소들을 말하며, 각각의 아이템에 적용할 수 있는 속성들이 존재합니다.

Flexbox에서 사용되는 속성 중 몇 가지 예시를 들면 다음과 같습니다.

flex-direction: 요소의 배치 방향을 지정합니다. row, column, row-reverse, column-reverse 등이 있습니다.

justify-content: 주 축을 기준으로 요소들을 정렬합니다. flex-start, flex-end, center, space-between, space-around 등이 있습니다.

align-items: 교차 축을 기준으로 요소들을 정렬합니다. flex-start, flex-end, center, stretch 등이 있습니다.

flex-wrap: 요소들이 한 줄에 배치되지 않고 여러 줄에 걸쳐서 배치될 수 있도록 지정합니다. nowrap, wrap, wrap-reverse 등이 있습니다.

Flexbox는 다양한 레이아웃 구성에 활용될 수 있으며, CSS 그리드와 함께 웹 페이지의 레이아웃을 구성하는 데 매우 유용합니다.

<br>

## 📌 8. Cascading에 관해서 설명해주세요.

Cascading은 CSS에서 스타일 규칙의 우선순위를 결정하는 프로세스입니다.

스타일 규칙은 여러 개의 충돌하는 규칙들이 적용될 때, 브라우저는 이러한 규칙들을 우선순위에 따라 적용합니다.

이때, Cascading은 다음의 세 가지 원칙을 기반으로 합니다.

1. 상속 (Inheritance)

부모 요소에서 설정된 스타일이 자식 요소에 상속되는 것을 의미합니다.

예를 들어, 부모 요소에서 color 속성을 지정하면, 자식 요소에서도 해당 색상이 적용됩니다.

2. 특정도 (Specificity)

스타일 규칙의 우선순위는 선택자의 구체성에 따라 결정됩니다.

예를 들어, id 선택자의 구체성이 class 선택자의 구체성보다 높습니다.

3. 선언 순서 (Declaration Order)

같은 우선순위를 갖는 스타일 규칙이 여러 개 있을 경우, 나중에 선언된 스타일 규칙이 우선합니다.

이러한 Cascading은 CSS의 기본 동작 원리 중 하나이며, 스타일 규칙을 적용하는 데 중요한 역할을 합니다.

따라서, Cascading의 원칙을 이해하고 적절하게 사용하는 것이 웹 개발에서 스타일링을 하는 데 필수적인 요소 중 하나입니다.

<br>

## 📌 9. Virtual dom 개념 설명 및 작동원리에 대해 설명해주세요

Virtual DOM은 React에서 사용되는 개념 중 하나로, 실제 브라우저 상의 DOM을 추상화한 가상의 DOM을 메모리 상에 유지하며, 이를 이용해 효율적으로 렌더링을 수행하는 방식입니다.

React에서는 상태 변화에 따라 Virtual DOM의 변화를 먼저 감지하고, 이전과 현재의 Virtual DOM을 비교하여 바뀐 부분만을 실제 DOM에 업데이트합니다.

이 과정에서 필요한 최소한의 변경 사항만을 수행하므로, 불필요한 렌더링을 방지하고 성능을 최적화할 수 있습니다.

Virtual DOM은 브라우저의 실제 DOM과는 별도로 존재하며, React 엔진이 이를 관리합니다.

Virtual DOM은 React 컴포넌트의 상태(state)와 속성(props)을 기반으로 구성되며, React 컴포넌트의 상태나 속성이 변경될 때마다 새로운 Virtual DOM이 생성됩니다.

그리고 이전과 새로운 Virtual DOM을 비교하여 변경된 부분을 찾아 실제 DOM에 업데이트합니다.

Virtual DOM은 이전과 현재의 상태를 비교하는 과정에서 효율적으로 작동하기 위해, diff 알고리즘을 사용합니다.

diff 알고리즘은 이전과 현재의 Virtual DOM을 비교하면서 변경된 부분을 찾아내는데, 이 과정에서 최소한의 연산만을 수행하여 성능을 최적화합니다.

또한, Virtual DOM은 React 컴포넌트의 라이프사이클 메소드와 함께 사용되어, 컴포넌트의 상태 변화에 따라 자동으로 렌더링을 수행하고, 실제 DOM에 반영됩니다.

이러한 기능을 통해 React는 높은 생산성과 효율성을 동시에 달성할 수 있습니다.

<br>

## 📌 10. Redux vs Redux-toolkit의 차이점에 대해 설명해주세요

Redux는 상태 관리 라이브러리로, React와 함께 주로 사용되며, 애플리케이션 전체에서 공유하는 상태를 관리합니다.

이러한 Redux는 많은 양의 boilerplate 코드를 포함하고 있어서, 개발자들이 Redux를 사용하는 데 어려움을 겪을 수 있습니다.

Redux-Toolkit은 Redux의 생산성을 높이기 위해 만들어진 라이브러리로, Redux를 더 쉽게 사용할 수 있도록 도와줍니다.

Redux-Toolkit은 Redux에서 자주 사용되는 기능들을 추상화하여 간단하고 효율적인 코드 작성을 가능하게 합니다.

Redux-Toolkit은 다음과 같은 기능을 제공합니다.

1. configureStore

Redux-Toolkit은 createStore 대신 configureStore를 제공합니다.

configureStore는 Redux에서 기본적으로 설정해야 할 여러가지 설정들을 기본값으로 제공하여 쉽게 사용할 수 있습니다.

2. createSlice

createSlice는 Reducer, Action, Action Creator를 한번에 생성할 수 있도록 도와줍니다.

코드량을 대폭 줄여주고, 코드 작성을 쉽게 할 수 있도록 해줍니다.

3. immer.js

Redux-Toolkit은 Immer.js를 사용하여 불변성을 관리합니다.

이를 통해 복잡한 불변성 코드를 작성하지 않아도 되어 코드 작성을 쉽게 할 수 있습니다.

4. 기타 기능

Redux-Toolkit은 Redux DevTools Extension을 기본적으로 사용할 수 있도록 지원합니다.

또한, Redux-Thunk를 사용하여 비동기 액션 처리를 지원합니다.

이러한 Redux-Toolkit의 기능들은 Redux를 사용하는 개발자들이 코드 작성을 더 쉽게하고, 생산성을 높이는 데 도움을 줍니다.

<br>

## 📌 11. Redux를 사용하는 이유가 무엇인가요?

1. 예측 가능한 상태 관리

Redux는 상태를 하나의 객체로 관리하고, 상태를 업데이트하는 모든 로직을 순차적으로 처리하기 때문에

예측 가능한 상태 관리가 가능합니다. 이를 통해 상태 변화에 따른 예측 불가능한 동작을 방지할 수 있습니다.

2. 중앙 집중화된 상태 관리

Redux는 전역 상태를 하나의 저장소(store)에 저장하고, 상태 업데이트를 위한 모든 로직을 중앙 집중화하여 처리합니다.

이를 통해 여러 컴포넌트에서 공유되는 상태를 효율적으로 관리할 수 있습니다.

3. 디버깅 용이성

Redux는 상태 변화에 대한 디버깅을 용이하게 만들어 줍니다.

모든 상태 변화는 action 객체를 통해 일어나기 때문에, 액션 로그를 저장하거나,

Redux DevTools와 같은 도구를 이용해 상태 변화를 쉽게 추적할 수 있습니다.

4. 서버 사이드 렌더링

Redux는 서버 사이드 렌더링을 지원합니다.

서버에서 렌더링된 HTML을 클라이언트로 전송할 수 있기 때문에 초기 로딩 속도를 개선할 수 있습니다.

5. 확장성

Redux는 미들웨어(middleware)를 통해 기능을 확장할 수 있습니다.

미들웨어를 사용하면, 액션의 전송 과정을 수정하거나, 비동기 로직을 처리할 수 있습니다.

이를 통해 Redux의 기능을 확장할 수 있습니다.

<br>

## 📌 12. Redux의 장단점에 대해 설명해주세요.

Redux는 JavaScript 애플리케이션 상태 관리 라이브러리입니다.

Redux를 사용하면 애플리케이션의 상태를 중앙 집중적으로 관리할 수 있으며, 데이터의 흐름이 예측 가능해져 유지보수가 용이해집니다.

하지만 Redux를 사용하는 것은 항상 최선의 선택은 아니며, 장단점이 있습니다.

### 장점

1. 중앙 집중적인 상태 관리

Redux는 모든 상태를 중앙 집중적으로 관리합니다.

이는 애플리케이션에서 발생하는 모든 상태 변경이 예측 가능하며, 애플리케이션의 상태를 한 눈에 볼 수 있게 해줍니다.

2. 예측 가능한 상태 관리

Redux는 상태 변경을 예측 가능하게 해줍니다.

이는 개발자가 상태의 흐름을 이해하고 유지보수할 수 있도록 해줍니다.

3. 쉬운 테스트

Redux는 상태 변경을 순수 함수로 처리하므로 테스트가 용이합니다.

이는 개발자가 코드의 품질을 향상시키고 버그를 더 쉽게 발견할 수 있도록 해줍니다.

4. 다양한 개발 환경과 호환: Redux는 React를 비롯한 다양한 프레임워크와 라이브러리에서 사용할 수 있습니다.

이는 개발자가 필요한 환경에서 Redux를 자유롭게 사용할 수 있도록 해줍니다.

<br>
Redux는 React 이외의 다른 프론트엔드 라이브러리나 프레임워크에서도 사용할 수 있습니다.

또한, React Native, Electron과 같은 데스크톱 애플리케이션 개발에서도 사용할 수 있습니다.

또한, Redux는 서버사이드 렌더링과 같은 환경에서도 사용될 수 있으며, React 이외의 라이브러리와도 함께 사용할 수 있습니다.

Redux는 단순히 React 애플리케이션에서 사용되는 것이 아니라, 다른 라이브러리와도 결합해서 사용할 수 있는 범용적인 상태 관리 라이브러리입니다.

<br>

### 단점

1. 높은 진입 장벽

Redux는 상태 관리 라이브러리 중에서도 비교적 복잡하고 추상적인 개념을 사용하기 때문에, 초기 학습 곡선이 높을 수 있습니다.

2. 많은 코드 작성

Redux를 사용하면 액션, 리듀서, 스토어, 컨테이너 등을 모두 직접 작성해야 합니다.

이는 초기 개발 시간을 늘릴 수 있습니다.

3. 너무 많은 리덕스 사용

작은 규모의 애플리케이션에는 Redux를 사용하기에는 적합하지 않을 수 있습니다.

Redux를 사용하면 불필요하게 복잡한 코드가 추가될 수 있으며, Redux 없이도 충분히 간단하게 구현할 수 있는 경우도 있습니다.

4. 불변성 유지

Redux에서는 불변성을 유지해야 하기 때문에, 객체나 배열 등을 수정할 때마다 복사해서 새로운 객체나 배열을 생성해야 합니다.

이는 성능 문제를 유발할 수 있습니다.

5. 불필요한 리렌더링

Redux는 언제나 전체 애플리케이션의 상태를 관리하므로, 상태가 바뀔 때마다 컴포넌트를 리렌더링해야 합니다.

이는 불필요한 리렌더링을 유발할 수 있으며, 이를 해결하기 위해 추가적인 최적화가 필요할 수 있습니다.

<br>

## 📌 13. 브라우저 렌더링 과정을 설명해주세요.

1. 사용자가 웹브라우저에 접속함.
2. 웹브라우저는 DNS 에게 host 의 ip 주소를 받아옴
3. ip 주소에 있는 서버를 찾아가
4. 서버와 브라우저는 3 Way-Handshake 를 실행함
5. 이후 브라우저는 서버에게 데이터( HTML, CSS, JS, 이미지, 폰트 파일 등 렌더링에 필요한 리소스)를 요청함. **(HTTP Request)**
6. 서버는 브라우저에게 데이터를 보내줌 **(HTTP Response)**
7. 브라우저는 서버로부터 받은 데이터를 해석함 (Parsing)
8. 브라우저의 렌더링 엔진은 HTML을 파싱하여 DOM Tree 를 생성함.
9. 이때, 렌더링 엔진이 style 태그를 만난다면 HTML 파싱을 중지하고 CSS 파싱 작업을 시작하여 CSSOM Tree를 생성.
10. CSS파싱을 마치면 HTML 파싱이 중단된 시점부터 다시 파싱 시작
11. 그러다가 scirpt 태그를 만나면 파싱을 중지하고 자바스크립트 엔진에게 제어 권한을 넘김
12. JS엔진은 코드를 해석하고 추상구문 Tree 인 AST(Abstract Syntax Tree)를 생성하고 실행한다.
13. 중단했던 HTML 파싱을 완료함.
14. DOM Tree + CSSOM Tree = Render Tree // **여기까지가 Construction**
15. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)을 계산하고(리플로우) 브라우저 화면에 HTML 요소를 페인팅한다. (리페인트)
16. UI Backend가 Render Tree의 노드들을 돌면서 UI 를 그림
17. 노드들의 레이어를 순서대로 구성하는 **Composition 단계** **layout~composition = Operation**
18. 최종적으로 사용자에게 화면 출력

<br/>

위 과정들은 모두 동기적으로 수행되기 때문에, 브라우저는 사용자의 입력을 기다리지 않고 계속 작업을 수행합니다.

하지만, 사용자의 입력은 높은 우선순위를 가지기 때문에, 브라우저는 사용자의 입력을 처리하기 전에 모든 작업을 중단하고 처리해야 합니다.

<br>

## 📌 14. 브라우저는 어떻게 동작 하나요?

브라우저는 다음과 같은 기능을 수행하는 소프트웨어입니다.

1. 사용자의 요청에 따라 웹페이지를 서버로부터 가져옵니다.
2. 웹페이지의 HTML, CSS, JavaScript 등의 파일을 파싱하고 실행하여 화면에 표시합니다.
3. 사용자와 상호작용하는 기능을 제공합니다.
4. 캐시를 이용하여 이전에 접근한 페이지를 더 빠르게 로드합니다.
5. 보안성을 제공하기 위해 악성코드를 차단하거나 경고 메시지를 표시합니다.

브라우저는 HTML, CSS, JavaScript 파일 등을 해석하고 실행하기 위해 렌더링 엔진, 자바스크립트 엔진, 네트워크 엔진 등의 다양한 구성 요소를 포함하고 있습니다.

또한, 화면에 표시되는 요소들을 관리하기 위해 DOM(Document Object Model)과 같은 구조를 사용합니다.

또한, 브라우저는 다양한 플랫폼에서 동작할 수 있도록 크로스 플랫폼 호환성을 제공하며, 웹페이지의 보안성을 강화하기 위한 기능도 제공합니다.

<br>

## 📌 15. Webpack, Babel, Polyfill에 대해 설명해주세요.

Webpack, Babel, Polyfill은 JavaScript를 효율적으로 개발하기 위해 사용되는 도구들입니다.

### Webpack

Webpack은 JavaScript 애플리케이션을 빌드하기 위한 모듈 번들러입니다.

여러 개의 JavaScript 파일을 하나로 묶어주고, CSS, 이미지 등의 파일도 모듈화하여 빌드 과정을 통해 최적화된 애플리케이션을 만들어 줍니다.

또한, Webpack은 자바스크립트 파일을 읽어오고 변환할 수 있는 로더(loader)와 플러그인(plugin)을 제공하므로 다양한 작업을 수행할 수 있습니다.

### Babel

Babel은 최신 버전의 자바스크립트 코드를 구 버전 브라우저에서도 동작할 수 있는 코드로 변환해주는 도구입니다.

최신 문법을 사용하여 개발한 자바스크립트 코드를 Babel을 이용하여 구 버전 브라우저에서도 동작할 수 있는 코드로 변환해주어, 호환성 문제를 해결할 수 있습니다.

### Polyfill

Polyfill은 구 버전 브라우저에서 동작하지 않는 최신 기술을 지원하는 코드를 의미합니다.

즉, 새로운 기술을 사용하여 개발한 애플리케이션을 구 버전 브라우저에서도 동작할 수 있도록 하기 위한 코드입니다.

이러한 Polyfill은 Babel과 함께 사용될 때 주로 사용되며, Babel이 자동으로 삽입해주기도 합니다.

<br>

이러한 도구들을 사용하여 개발을 하면, 최신 기술을 사용하여 개발할 수 있으며, 호환성 문제를 해결할 수 있어 개발 생산성을 높일 수 있습니다.

<br>

## 📌 16. CSR과 SSR의 차이는 무엇인가요?

SSR과 CSR의 근본적인 차이는 렌더링 준비를 어디서 하느냐 입니다.

CSR과 SSR은 모두 웹 애플리케이션에서 클라이언트와 서버 간의 데이터 교환을 처리하는 방식입니다.

CSR(Client-Side Rendering)은 브라우저에서 페이지를 렌더링할 때 서버로부터 받은 HTML, CSS, JavaScript와 같은 정적 파일들을 기반으로 동적인 컨텐츠를 브라우저에서 자바스크립트를 통해 렌더링하는 방식입니다.

즉, 브라우저에서 초기 로딩 시 서버로부터 HTML, CSS, JavaScript 등의 파일을 다운로드하고, 이후 필요한 데이터를 AJAX 등을 통해 서버에 요청하여 동적으로 화면을 업데이트합니다.

CSR 방식은 초기 로딩 속도가 빠르며, 웹 애플리케이션에서 클라이언트에서 처리하는 비즈니스 로직이 많을 경우 적합합니다.

반면에 SSR(Server-Side Rendering)은 서버에서 데이터를 처리하고, 처리된 데이터를 HTML로 렌더링하여 브라우저로 전송하는 방식입니다.

브라우저에서 서버로부터 HTML 파일을 요청하면 서버에서는 데이터를 처리하여 HTML로 렌더링하고, 이를 브라우저로 전송하여 화면에 렌더링합니다.

SSR 방식은 초기 로딩 속도가 느리지만, 검색 엔진 최적화(SEO)가 용이하고, 클라이언트에서 처리하는 비즈니스 로직이 적을 경우 유리합니다.

CSR과 SSR 모두 장단점이 있으며, 선택은 개발하고자 하는 웹 애플리케이션의 특성과 목적에 따라 다를 수 있습니다.

최근에는 두 방식을 혼합하여 사용하는 경우도 있으며, 이를 '최적화된 SSR'이라고 부르기도 합니다.

<br>

### SSR

렌더링이 서버측에서 이루어지는 방식을 말합니다.

1. 유저가 Website 요청을 보낸다.
2. 서버는 렌더링에 사용될 HTML 파일들을 생성하여 클라이언트로 전달한다.
3. 클라이언트는 받은 HTML 파일들을 우선 렌더링 하는데 보여지는 것만 가능하고 조작은 불가능하다.
4. 클라이언트는 JS파일을 다운로드한다.
5. 유저는 화면 내용을 볼 수 있고 유저의 조작들이 기록된다. (아직 실행X)
6. 클라이언트가 JS Framework를 실행시킨다.
7. 앞서 기록된 유저의 조작들이 실행되며, 이 시점부터 페이지의 정상적인 이용이 가능하다.

<br>

### CSR

렌더링이 클라이언트 측에서 이루어지는 방식을 말합니다.

1. 유저가 Website 요청을 보낸다.
2. CDN이 JS로 접근할 수 있는 HTML 파일들을 보낸다.
3. 클라이언트는 HTML과 JS를 다운로드한다.
4. JS가 실행되고, API를 호출하여 데이터를 요청한다.
5. 서버는 API로부터 요청에 데이터로 응답한다.
6. API로부터 도착한 데이터는 화면의 placeholder들을 채우고 이 시점부터 페이지의 정상적인 이용이 가능하다.

<br>

## 둘의 차이

### SSR 장점

- JS가 다운로드 되는 동안 사용자는 화면의 일정부분을 경험할 수 있다.
- 빠른 초기로딩
- 화면을 구성하는 각각의 페이지가 존재하기 때문에 SEO에 유리

<br>

### SSR 단점

- 빠른 초기 로딩으로 TTV(Time To View)와 TTI(Time TO Interact) 사이의 시간 간격이 생김
- 첫 페이지로딩은 빠르지만 이후 로딩들은 CSR보다 느린 속도를 가짐
- 추가 로딩시 화면 깜빡임 존재
- 화면 변경시 화면을 구성하는 모든 리소스들을 매번 다운로드 받아야함
- 매번 서버에 요청을 하기 때문에 서버의 많은 리소스들을 필요로 하여 서버에 부하를 준다.

<br>

### CSR 장점

- 첫 페이지 로딩은 느리지만 이후 로딩들은 SSR 보다 빠른 속도를 가짐.
- 추가 로딩시 화면 깜빡임 없음
- 화면 변경시 변경에 필요한 리소스들만 다운로드 받으면 됨.
- 서버에 부하가 적다.

<br>

### CSR 단점

- 한꺼번에 다운로드를 받기 때문에 그동안 사용자는 화면의 어떠한 부분도 경험할 수 없다.
- SSR과 비교하면 비교적 느린 초기 로딩
- SEO에 적합하지 않음. (JS까지 모두 다운 되어야 페이지가 로드되기 때문이다.)

<br>

## 어느 환경에서 사용하면 좋을까?

### SSR

- 한 번에 모든 파일을 다운로드 받을 필요가 없으므로 네트워크가 느린 곳
- 초기 로딩시에도 사용자의 경험을 우선시 할 때
- SEO를 신경 쓸 때
- 웹사이트에 동적인 컨텐츠가 많을 때

<br>

### CSR

- 한 번에 모든 파일을 다운로드 받으므로 네트워크가 빠른 곳
- 초기 로딩시 사용자의 경험을 비교적 덜 신경 쓸 때
- SEO를 신경쓰지 않을 때

<br>

## 📌 17. 회사 지원 동기를 말씀해주세요.

<br>

## 📌 18. 최근 경험했던 기억에 남는 에러에 대해 말씀해주세요.

<br>

## 📌 19. 요즘 공부하고 있는 것을 말씀해주세요.

<br>

## 📌 20. 자바스크립트를 공부하면서 가장 인상 깊었던 것을 말씀해주세요.

제너레이터(Generator)는 ES6(ECMAScript 2015)에서 도입된 함수입니다. 함수의 실행을 일시 중지하고 나중에 이어서 실행할 수 있는 기능을 제공합니다. 제너레이터를 이용하면 비동기적인 작업을 동기적으로 처리할 수 있으며, 이를 통해 코드의 가독성과 유지보수성을 높일 수 있습니다.

제너레이터 함수는 function\* 키워드를 사용하여 정의할 수 있습니다. 제너레이터 함수 내부에는 yield 키워드를 사용하여 값을 반환하고 함수의 실행을 일시 중지할 수 있습니다. next() 메서드를 호출하면 함수 실행을 이어서 진행할 수 있습니다.

제너레이터 함수는 제너레이터 객체를 반환하며, 제너레이터 객체는 next() 메서드를 가지고 있습니다. next() 메서드는 객체의 프로퍼티로 value와 done을 가지며, value는 yield 키워드에 의해 반환된 값이고, done은 함수의 실행이 끝났는지 여부를 나타냅니다.

제너레이터는 비동기 프로그래밍에서 많이 사용됩니다. 예를 들어, 데이터를 비동기적으로 가져온 후에 처리할 수 있도록 제너레이터를 활용할 수 있습니다. 이를 통해 비동기 코드의 가독성을 높이고 유지보수성을 높일 수 있습니다.

제너레이터를 사용하면 함수형 프로그래밍을 할 수 있습니다. 제너레이터 함수는 호출되면 실행 중인 컨텍스트를 유지하면서 제너레이터 이터레이터를 반환하고, 이터레이터는 next() 메서드를 사용하여 실행을 제어할 수 있습니다.

제너레이터를 사용하면 비동기 작업을 쉽게 처리할 수 있습니다. 예를 들어, 제너레이터를 사용하여 비동기 API 호출을 순차적으로 처리할 수 있습니다. 또한 제너레이터를 사용하여 무한한 시퀀스를 생성하거나 이터레이션 프로토콜을 구현할 수도 있습니다. 이는 함수형 프로그래밍에서 매우 유용합니다.

<br>
