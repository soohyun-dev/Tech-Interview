# 23년 3월 첫째주 Weekly Study

<br>

## 📜 목차

### cs

- 브라우저 주소창에 www.google.com을 입력하면 어떤 일이 일어나나요?
- DNS에 대해 설명해주세요.
- GET과 POST의 차이는 무엇인가요?
- REST API에 대해 설명해주세요.

<br>

### javascript + html + css

- Promise와 Callback 차이를 설명해주세요.
- 콜백 지옥(Callback hell)을 해결하는 방법을 말씀해주세요.
- Flexbox를 사용해보셨나요?
- Cascading에 관해서 설명해주세요.

<br>

### react + redux

- Virtual DOM 작동 원리에 대해 설명해주세요.
- Virtual DOM 이 무엇인지 설명해주세요.
- Redux를 사용하는 이유가 무엇인가요?
- Redux의 장단점에 대해 설명해주세요.

<br>

### frontend

- 브라우저 렌더링 과정을 설명해주세요.
- 브라우저는 어떻게 동작 하나요?
- Webpack, Babel, Polyfill에 대해 설명해주세요.
- CSR과 SSR의 차이는 무엇인가요?

<br>

### 기타(인성 면접)

- 회사 지원 동기를 말씀해주세요.
- 최근 경험했던 기억에 남는 에러에 대해 말씀해주세요.
- 요즘 공부하고 있는 것을 말씀해주세요.
- 자바스크립트를 공부하면서 가장 인상 깊었던 것을 말씀해주세요.

<br>

## 📌 1. 브라우저 주소창에 www.google.com을 입력하면 어떤 일이 일어나나요?

1. 사용자가 웹 브라우저를 통해 google.com 을 입력하면 URL 주소 중 도메인 네임 부분을 DNS 서버에서 검색합니다.
2. DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달합니다.
3. 브라우저는 HTTP 프로토콜을 사용하여 요청 메시지를 생성하고 HTTP 요청 메시지는 TCP/IP 프로토콜을 사용하여 서버로 전송됩니다.
4. 서버는 response 메시지를 생성하여 다시 브라우저에게 데이터를 전송합니다.
5. 브라우저는 response를 받아 파싱하여 화면에 렌더링합니다.

<br>

브라우저는 입력된 주소가 URL(Uniform Resource Locator) 형식인지 확인합니다. URL은 인터넷 상의 리소스(웹 페이지, 이미지, 동영상 등)의 위치를 나타내는 문자열입니다.

브라우저는 입력된 도메인 이름인 "www.google.com"이 IP 주소로 변환될 필요가 있습니다. 이를 위해, 브라우저는 먼저 자신의 로컬 DNS 캐시에 도메인 이름에 대한 IP 주소를 찾고, 캐시에 없는 경우에는 운영체제의 호스트 파일을 검색합니다. 만약 호스트 파일에도 없는 경우에는 DNS 서버에 쿼리를 보내서 IP 주소를 검색합니다.

DNS 서버는 입력된 도메인 이름을 최상위 도메인부터 순차적으로 검색하여 IP 주소를 찾습니다. 먼저 루트 DNS 서버에 쿼리를 보내고, 그 다음에는 .com 최상위 도메인 서버에 쿼리를 보내서 구글의 DNS 서버 주소를 알아냅니다.

브라우저는 구글의 DNS 서버 주소를 사용하여 구글 서버에 HTTP 요청을 보냅니다.

구글 서버는 요청된 페이지에 대한 응답을 보내고, 브라우저는 이를 받아서 페이지를 렌더링하여 사용자에게 보여줍니다.

<br>

## 📌 2. DNS에 대해 설명해주세요.

DNS는 Domain Name System의 약자로, 인터넷에서 사용되는 주소를 숫자로 된 IP 주소에서 사람이 이해하기 쉬운 도메인 이름으로 변환해주는 시스템입니다.

인터넷에 연결된 기기는 모두 IP 주소를 사용하여 통신을 합니다. 하지만 IP 주소는 일반 사용자가 기억하기 어렵고, 주소를 입력하기에도 불편합니다. 따라서 DNS는 도메인 이름과 IP 주소를 매핑하는 역할을 하여, 도메인 이름을 입력하면 해당 도메인 이름에 대한 IP 주소를 찾아서 사용자 기기로 전달해주는 역할을 합니다.

DNS는 계층 구조를 가지고 있으며, 이를 DNS 트리라고 부릅니다. 최상위에는 루트 DNS 서버가 있으며, 그 하위에는 최상위 도메인(.com, .net, .org 등)의 DNS 서버, 그리고 그 다음 하위 도메인의 DNS 서버와 계속하여 하위 도메인의 DNS 서버로 이어집니다.

DNS 서버는 일반적으로 ISP(Internet Service Provider)나 공공 DNS 서비스 업체가 운영합니다. 사용자가 도메인 이름을 입력하면, 우선 자신의 컴퓨터나 라우터에 캐시된 DNS 정보를 확인하고, 없을 경우에는 DNS 서버에 질의하여 IP 주소를 받아옵니다.

<br>

## 📌 3. GET과 POST의 차이는 무엇인가요?

GET과 POST는 HTTP(Hypertext Transfer Protocol) 요청 방식 중에서 가장 많이 사용되는 두 가지 방식입니다.

이 둘의 가장 큰 차이점은 데이터를 전송하는 방식과 목적에 있습니다.

GET 방식은 서버로부터 데이터를 요청할 때 사용되며, 요청하는 데이터를 URL에 포함하여 전송합니다.

예를 들어, 웹 브라우저에서 구글 검색창에 검색어를 입력하면, 검색어가 URL의 쿼리 스트링에 포함되어 GET 요청으로 전송됩니다.

이 방식은 URL에 요청 정보를 모두 포함하기 때문에, 요청을 처리하는 서버나 네트워크에서 쉽게 볼 수 있고, 캐싱이 가능합니다.

하지만 보안상 취약점이 존재할 수 있으며, 전송할 수 있는 데이터 크기가 제한적입니다.

반면 POST 방식은 서버에 데이터를 전송할 때 사용되며, 요청하는 데이터를 HTTP 본문에 포함하여 전송합니다.

예를 들어, 회원가입 폼을 작성하고 제출할 때, 입력한 데이터는 POST 요청으로 전송됩니다.

이 방식은 URL에 데이터가 노출되지 않기 때문에 보안성이 높으며, 전송할 수 있는 데이터 크기도 무제한입니다.

하지만, 캐싱이 불가능하기 때문에 GET 방식보다는 느리고, 보안상 취약점이 존재할 수 있습니다.

따라서, GET 방식은 정보를 가져오는 용도로 사용되며, POST 방식은 정보를 서버에 전송하거나 수정하는 용도로 사용됩니다.

보안이 중요한 데이터 전송이나, 대량의 데이터를 전송해야 할 때는 POST 방식을 사용하는 것이 좋습니다.
<br>

## 📌 4. REST API에 대해 설명해주세요.

REST API는 Representational State Transfer(표현 상태 전이)의 약자로, 웹 상에서 서로 다른 시스템 간에 상호작용하는데 사용되는 아키텍처 스타일입니다.

REST API를 통해 클라이언트는 서버에 데이터를 요청하거나 수정, 삭제할 수 있습니다.

REST API는 자원, HTTP 메서드, 표현 방식, 상태 코드 등으로 구성됩니다.

자원은 URI(Uniform Resource Identifier)로 표현되며, HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 자원에 대한 요청을 수행합니다.

표현 방식은 클라이언트와 서버 간의 데이터 전송 방식으로, 일반적으로 JSON, XML 등이 사용됩니다.

상태 코드는 서버가 요청을 처리한 후 응답 상태를 나타내는 코드입니다.

REST의 기본 원칙을 성실히 지킨 서비스 디자인을 `RESTful`이라고 표현한다.

<br>

REST API의 장점은 다음과 같습니다.

높은 확장성: REST API는 URI를 통해 자원을 표현하기 때문에, 다양한 시스템에서 사용하기 쉽습니다.

높은 호환성: REST API는 HTTP 프로토콜을 사용하므로, 다양한 클라이언트와 서버 간에 상호작용할 수 있습니다.

간결하고 가독성이 높음: REST API는 자원, HTTP 메서드, 표현 방식, 상태 코드 등으로 구성되어 있어서, 이해하기 쉽고 가독성이 높습니다.

캐싱 가능: REST API는 HTTP 프로토콜을 사용하므로, 캐싱이 가능하며, 네트워크 대역폭을 절약할 수 있습니다.

분리된 클라이언트-서버 구조: REST API는 클라이언트와 서버가 분리되어 있기 때문에, 각각의 시스템을 독립적으로 개발할 수 있습니다.

<br>

## 📌 5. Promise와 Callback 차이를 설명해주세요.

자바스크립트에서는 비동기 처리를 위한 패턴중 하나로 콜백 함수를 사용합니다.

전통적인 콜백 패턴은 '콜백 헬'로 인해 가독성이 나쁘고 비동기 처리 중 발생한 에러의 처리가 곤란하며 여러 개의 비동기 처리를 한 번에 처리하는데 한계가 있습니다.

ES6에서 도입된 프로미스는, 이러한 콜백 함수의 문제점인 비동기 처리를 해결하기 위한 또 하나의 패턴입니다.

프로미스는 호스트 객체가 아닌 ECMAScript 사양에 정의된 표준 빌트인 객체입니다.

Promise 객체는 비동기 작업의 성공과 실패를 처리하는 콜백 함수를 등록할 수 있습니다.

Promise 객체는 성공 시 resolve 콜백 함수와 실패 시 reject 콜백 함수를 등록할 수 있습니다.

콜백 함수는 작업이 완료될 때마다 매번 호출되며, 이는 코드의 가독성을 해치고 디버깅이 어렵게 만들 수 있습니다.

반면, Promise는 비동기 작업의 결과에 대한 콜백 함수를 한 번만 등록하므로 코드의 가독성이 높아지고, 디버깅이 쉬워집니다.

또한, 여러 개의 비동기 작업을 순차적으로 실행해야 하는 경우, 콜백 함수를 사용하면 콜백 지옥(Callback Hell)이라는 코드의 중첩이 깊어지는 문제가 발생할 수 있습니다.

이를 해결하기 위해 Promise 객체를 사용하면 비동기 작업을 체인 형태로 실행할 수 있어 가독성이 높아집니다.

따라서, Promise는 코드의 가독성이 좋고 디버깅이 쉬우며, 콜백 지옥 문제를 해결하기 위한 좋은 대안입니다.

<br>

## 📌 6. 콜백 지옥(Callback hell)을 해결하는 방법을 말씀해주세요.

1. 콜백 함수를 사용하지 않는 방법

Promise나 async/await를 사용하여 콜백 함수를 대체할 수 있습니다.

2. 모듈화

코드를 모듈화하여 작은 단위로 나누고, 이를 조합하여 처리하는 방법입니다.

이를 통해 코드의 가독성을 높이고, 유지보수를 쉽게 할 수 있습니다.

3. 이름이 있는 함수로 콜백 함수를 대체

이름이 있는 함수를 사용하여 콜백 함수를 대체하면 가독성이 향상됩니다.

또한, 함수를 재사용할 수 있어 유지보수에 용이합니다.

4. 프라미스 체이닝

Promise 객체를 사용하여 비동기 작업을 처리할 때, then 메서드를 체이닝하여 사용할 수 있습니다.

이를 통해 중첩된 콜백 함수를 피할 수 있으며, 가독성이 향상됩니다.

5. 콜백 함수를 별도로 선언

콜백 함수를 변수로 선언하여 사용하면 가독성이 향상됩니다.

또한, 콜백 함수를 재사용할 수 있어 유지보수에 용이합니다.

<br>

## 📌 7. Flexbox를 사용해보셨나요?

Flexbox는 레이아웃을 구성하기 위한 CSS 속성이며, 부모 요소에 적용하여 자식 요소들을 유연하게 배치할 수 있습니다.

Flexbox를 사용하면 요소의 크기와 위치를 쉽게 조정할 수 있으며, 반응형 디자인에도 용이합니다.

Flexbox를 사용하기 위해서는 부모 요소에 display: flex;를 설정하고, 자식 요소에는 flex 속성을 적용합니다.

이때, flex 속성은 다음과 같은 세 가지 속성으로 구성됩니다.

1. flex-grow: 아이템의 증가 너비 비율을 설정합니다.
2. flex-shrink: 아이템의 감소 너비 비율을 설정합니다.
3. flex-basis: 아이템의 기본 너비를 설정합니다.

또한, Flexbox를 사용할 때는 justify-content, align-items, align-content 등의 속성을 사용하여 아이템들을 배치할 수 있습니다.

<br>

## 📌 8. Cascading에 관해서 설명해주세요.

Cascading은 CSS에서 스타일 규칙의 우선순위를 결정하는 프로세스입니다.

스타일 규칙은 여러 개의 충돌하는 규칙들이 적용될 때, 브라우저는 이러한 규칙들을 우선순위에 따라 적용합니다.

이때, Cascading은 다음의 세 가지 원칙을 기반으로 합니다.

1. 상속 (Inheritance)

부모 요소에서 설정된 스타일이 자식 요소에 상속되는 것을 의미합니다.

예를 들어, 부모 요소에서 color 속성을 지정하면, 자식 요소에서도 해당 색상이 적용됩니다.

2. 특정도 (Specificity)

스타일 규칙의 우선순위는 선택자의 구체성에 따라 결정됩니다.

예를 들어, id 선택자의 구체성이 class 선택자의 구체성보다 높습니다.

3. 선언 순서 (Declaration Order)

같은 우선순위를 갖는 스타일 규칙이 여러 개 있을 경우, 나중에 선언된 스타일 규칙이 우선합니다.

이러한 Cascading은 CSS의 기본 동작 원리 중 하나이며, 스타일 규칙을 적용하는 데 중요한 역할을 합니다.

따라서, Cascading의 원칙을 이해하고 적절하게 사용하는 것이 웹 개발에서 스타일링을 하는 데 필수적인 요소 중 하나입니다.

<br>

## 📌 9. Virtual dom 개념 설명 및 작동원리에 대해 설명해주세요

Virtual DOM은 React와 같은 UI 라이브러리에서 사용되는 개념으로,

UI 요소를 실제 DOM에 바로 반영하는 대신 가상의 DOM 트리를 사용하여 성능을 최적화하는 기술입니다.

Virtual DOM의 작동 원리는 다음과 같습니다.

1. 데이터 변경

React에서 상태(state)나 프로퍼티(props)가 변경되면, Virtual DOM을 업데이트합니다.

2. 가상 DOM 업데이트

업데이트된 상태나 프로퍼티에 맞추어, React는 가상 DOM을 업데이트합니다.

이때, 가상 DOM은 실제 DOM과 동일한 구조를 가지지만, 메모리 상에서만 존재하는 가상 요소들로 이루어진 DOM 트리입니다.

3. 비교 알고리즘 실행

이전 가상 DOM과 새로운 가상 DOM을 비교하는 알고리즘이 실행됩니다.

이 비교 알고리즘은 최소한의 업데이트만을 적용하여 리소스를 효율적으로 사용합니다.

4. 실제 DOM 업데이트

변경된 부분만을 실제 DOM에 반영합니다.

이렇게 함으로써, UI 업데이트를 더 빠르고 효율적으로 처리할 수 있습니다.

이러한 작동 원리를 통해, Virtual DOM은 UI 업데이트를 효율적으로 처리할 수 있어서, 매우 빠른 성능을 제공합니다.

또한, 가상 DOM은 메모리 상에서만 존재하기 때문에, 브라우저 상에서 실제 DOM을 변경하는 작업보다 더 적은 리소스를 사용합니다.

<br>

## 📌 10. Redux vs Redux-toolkit의 차이점에 대해 설명해주세요

Redux는 상태 관리 라이브러리로, React와 함께 사용되며, 애플리케이션 전체에서 공유하는 상태를 관리합니다.

이러한 Redux는 많은 양의 boilerplate 코드를 포함하고 있어서, 개발자들이 Redux를 사용하는 데 어려움을 겪을 수 있습니다.

Redux-Toolkit은 Redux의 생산성을 높이기 위해 만들어진 라이브러리로, Redux를 더 쉽게 사용할 수 있도록 도와줍니다.

Redux-Toolkit은 Redux에서 자주 사용되는 기능들을 추상화하여 간단하고 효율적인 코드 작성을 가능하게 합니다.

Redux-Toolkit은 다음과 같은 기능을 제공합니다.

1. configureStore

Redux-Toolkit은 createStore 대신 configureStore를 제공합니다.

configureStore는 Redux에서 기본적으로 설정해야 할 여러가지 설정들을 기본값으로 제공하여 쉽게 사용할 수 있습니다.

2. createSlice

createSlice는 Reducer, Action, Action Creator를 한번에 생성할 수 있도록 도와줍니다.

코드량을 대폭 줄여주고, 코드 작성을 쉽게 할 수 있도록 해줍니다.

3. immer.js

Redux-Toolkit은 Immer.js를 사용하여 불변성을 관리합니다.

이를 통해 복잡한 불변성 코드를 작성하지 않아도 되어 코드 작성을 쉽게 할 수 있습니다.

4. 기타 기능

Redux-Toolkit은 Redux DevTools Extension을 기본적으로 사용할 수 있도록 지원합니다.

또한, Redux-Thunk를 사용하여 비동기 액션 처리를 지원합니다.

이러한 Redux-Toolkit의 기능들은 Redux를 사용하는 개발자들이 코드 작성을 더 쉽게하고, 생산성을 높이는 데 도움을 줍니다.

<br>

## 📌 11. Redux를 사용하는 이유가 무엇인가요?

1. 예측 가능한 상태 관리

Redux는 상태를 하나의 객체로 관리하고, 상태를 업데이트하는 모든 로직을 순차적으로 처리하기 때문에

예측 가능한 상태 관리가 가능합니다. 이를 통해 상태 변화에 따른 예측 불가능한 동작을 방지할 수 있습니다.

2. 중앙 집중화된 상태 관리

Redux는 전역 상태를 하나의 저장소(store)에 저장하고, 상태 업데이트를 위한 모든 로직을 중앙 집중화하여 처리합니다.

이를 통해 여러 컴포넌트에서 공유되는 상태를 효율적으로 관리할 수 있습니다.

3. 디버깅 용이성

Redux는 상태 변화에 대한 디버깅을 용이하게 만들어 줍니다.

모든 상태 변화는 action 객체를 통해 일어나기 때문에, 액션 로그를 저장하거나,

Redux DevTools와 같은 도구를 이용해 상태 변화를 쉽게 추적할 수 있습니다.

4. 서버 사이드 렌더링

Redux는 서버 사이드 렌더링을 지원합니다.

서버에서 렌더링된 HTML을 클라이언트로 전송할 수 있기 때문에 초기 로딩 속도를 개선할 수 있습니다.

5. 확장성

Redux는 미들웨어(middleware)를 통해 기능을 확장할 수 있습니다.

미들웨어를 사용하면, 액션의 전송 과정을 수정하거나, 비동기 로직을 처리할 수 있습니다.

이를 통해 Redux의 기능을 확장할 수 있습니다.

<br>

## 📌 12. Redux의 장단점에 대해 설명해주세요.

Redux는 JavaScript 애플리케이션 상태 관리 라이브러리입니다.

Redux를 사용하면 애플리케이션의 상태를 중앙 집중적으로 관리할 수 있으며, 데이터의 흐름이 예측 가능해져 유지보수가 용이해집니다.

하지만 Redux를 사용하는 것은 항상 최선의 선택은 아니며, 장단점이 있습니다.

### 장점

1. 중앙 집중적인 상태 관리

Redux는 모든 상태를 중앙 집중적으로 관리합니다.

이는 애플리케이션에서 발생하는 모든 상태 변경이 예측 가능하며, 애플리케이션의 상태를 한 눈에 볼 수 있게 해줍니다.

2. 예측 가능한 상태 관리

Redux는 상태 변경을 예측 가능하게 해줍니다.

이는 개발자가 상태의 흐름을 이해하고 유지보수할 수 있도록 해줍니다.

3. 쉬운 테스트

Redux는 상태 변경을 순수 함수로 처리하므로 테스트가 용이합니다.

이는 개발자가 코드의 품질을 향상시키고 버그를 더 쉽게 발견할 수 있도록 해줍니다.

4. 다양한 개발 환경과 호환: Redux는 React를 비롯한 다양한 프레임워크와 라이브러리에서 사용할 수 있습니다.

이는 개발자가 필요한 환경에서 Redux를 자유롭게 사용할 수 있도록 해줍니다.

<br>

### 단점

1. 높은 진입 장벽

Redux는 상태 관리 라이브러리 중에서도 비교적 복잡하고 추상적인 개념을 사용하기 때문에, 초기 학습 곡선이 높을 수 있습니다.

2. 많은 코드 작성

Redux를 사용하면 액션, 리듀서, 스토어, 컨테이너 등을 모두 직접 작성해야 합니다.

이는 초기 개발 시간을 늘릴 수 있습니다.

3. 너무 많은 리덕스 사용

작은 규모의 애플리케이션에는 Redux를 사용하기에는 적합하지 않을 수 있습니다.

Redux를 사용하면 불필요하게 복잡한 코드가 추가될 수 있으며, Redux 없이도 충분히 간단하게 구현할 수 있는 경우도 있습니다.

4. 불변성 유지

Redux에서는 불변성을 유지해야 하기 때문에, 객체나 배열 등을 수정할 때마다 복사해서 새로운 객체나 배열을 생성해야 합니다.

이는 성능 문제를 유발할 수 있습니다.

5. 불필요한 리렌더링

Redux는 언제나 전체 애플리케이션의 상태를 관리하므로, 상태가 바뀔 때마다 컴포넌트를 리렌더링해야 합니다.

이는 불필요한 리렌더링을 유발할 수 있으며, 이를 해결하기 위해 추가적인 최적화가 필요할 수 있습니다.

<br>

## 📌 13. 브라우저 렌더링 과정을 설명해주세요.

1. 사용자가 웹브라우저에 접속함.
2. 웹브라우저는 DNS 에게 host 의 ip 주소를 받아옴
3. ip 주소에 있는 서버를 찾아가
4. 서버와 브라우저는 3 Way-Handshake 를 실행함
5. 이후 브라우저는 서버에게 데이터( HTML, CSS, JS, 이미지, 폰트 파일 등 렌더링에 필요한 리소스)를 요청함. **(HTTP Request)**
6. 서버는 브라우저에게 데이터를 보내줌 **(HTTP Response)**
7. 브라우저는 서버로부터 받은 데이터를 해석함 (Parsing)
8. 브라우저의 렌더링 엔진은 HTML을 파싱하여 DOM Tree 를 생성함.
9. 이때, 렌더링 엔진이 style 태그를 만난다면 HTML 파싱을 중지하고 CSS 파싱 작업을 시작하여 CSSOM Tree를 생성.
10. CSS파싱을 마치면 HTML 파싱이 중단된 시점부터 다시 파싱 시작
11. 그러다가 scirpt 태그를 만나면 파싱을 중지하고 자바스크립트 엔진에게 제어 권한을 넘김
12. JS엔진은 코드를 해석하고 추상구문 Tree 인 AST(Abstract Syntax Tree)를 생성하고 실행한다.
13. 중단했던 HTML 파싱을 완료함.
14. DOM Tree + CSSOM Tree = Render Tree // **여기까지가 Construction**
15. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)을 계산하고(리플로우) 브라우저 화면에 HTML 요소를 페인팅한다. (리페인트)
16. UI Backend가 Render Tree의 노드들을 돌면서 UI 를 그림
17. 노드들의 레이어를 순서대로 구성하는 **Composition 단계** **layout~composition = Operation**
18. 최종적으로 사용자에게 화면 출력

<br/>

위 과정들은 모두 동기적으로 수행되기 때문에, 브라우저는 사용자의 입력을 기다리지 않고 계속 작업을 수행합니다.

하지만, 사용자의 입력은 높은 우선순위를 가지기 때문에, 브라우저는 사용자의 입력을 처리하기 전에 모든 작업을 중단하고 처리해야 합니다.

<br>

## 📌 14. 브라우저는 어떻게 동작 하나요?

브라우저는 다음과 같은 기능을 수행하는 소프트웨어입니다.

1. 사용자의 요청에 따라 웹페이지를 서버로부터 가져옵니다.
2. 웹페이지의 HTML, CSS, JavaScript 등의 파일을 파싱하고 실행하여 화면에 표시합니다.
3. 사용자와 상호작용하는 기능을 제공합니다.
4. 캐시를 이용하여 이전에 접근한 페이지를 더 빠르게 로드합니다.
5. 보안성을 제공하기 위해 악성코드를 차단하거나 경고 메시지를 표시합니다.

브라우저는 HTML, CSS, JavaScript 파일 등을 해석하고 실행하기 위해 렌더링 엔진, 자바스크립트 엔진, 네트워크 엔진 등의 다양한 구성 요소를 포함하고 있습니다.

또한, 화면에 표시되는 요소들을 관리하기 위해 DOM(Document Object Model)과 같은 구조를 사용합니다.

또한, 브라우저는 다양한 플랫폼에서 동작할 수 있도록 크로스 플랫폼 호환성을 제공하며, 웹페이지의 보안성을 강화하기 위한 기능도 제공합니다.

<br>

## 📌 15. Webpack, Babel, Polyfill에 대해 설명해주세요.

Webpack, Babel, Polyfill은 JavaScript를 효율적으로 개발하기 위해 사용되는 도구들입니다.

### Webpack

Webpack은 JavaScript 애플리케이션을 빌드하기 위한 모듈 번들러입니다.

여러 개의 JavaScript 파일을 하나로 묶어주고, CSS, 이미지 등의 파일도 모듈화하여 빌드 과정을 통해 최적화된 애플리케이션을 만들어 줍니다.

또한, Webpack은 자바스크립트 파일을 읽어오고 변환할 수 있는 로더(loader)와 플러그인(plugin)을 제공하므로 다양한 작업을 수행할 수 있습니다.

### Babel

Babel은 최신 버전의 자바스크립트 코드를 구 버전 브라우저에서도 동작할 수 있는 코드로 변환해주는 도구입니다.

최신 문법을 사용하여 개발한 자바스크립트 코드를 Babel을 이용하여 구 버전 브라우저에서도 동작할 수 있는 코드로 변환해주어, 호환성 문제를 해결할 수 있습니다.

### Polyfill

Polyfill은 구 버전 브라우저에서 동작하지 않는 최신 기술을 지원하는 코드를 의미합니다.

즉, 새로운 기술을 사용하여 개발한 애플리케이션을 구 버전 브라우저에서도 동작할 수 있도록 하기 위한 코드입니다.

이러한 Polyfill은 Babel과 함께 사용될 때 주로 사용되며, Babel이 자동으로 삽입해주기도 합니다.

<br>

이러한 도구들을 사용하여 개발을 하면, 최신 기술을 사용하여 개발할 수 있으며, 호환성 문제를 해결할 수 있어 개발 생산성을 높일 수 있습니다.

<br>

## 📌 16. CSR과 SSR의 차이는 무엇인가요?

SSR과 CSR의 근본적인 차이는 렌더링 준비를 어디서 하느냐 입니다.

CSR과 SSR은 모두 웹 애플리케이션에서 클라이언트와 서버 간의 데이터 교환을 처리하는 방식입니다.

CSR(Client-Side Rendering)은 브라우저에서 페이지를 렌더링할 때 서버로부터 받은 HTML, CSS, JavaScript와 같은 정적 파일들을 기반으로 동적인 컨텐츠를 브라우저에서 자바스크립트를 통해 렌더링하는 방식입니다.

즉, 브라우저에서 초기 로딩 시 서버로부터 HTML, CSS, JavaScript 등의 파일을 다운로드하고, 이후 필요한 데이터를 AJAX 등을 통해 서버에 요청하여 동적으로 화면을 업데이트합니다.

CSR 방식은 초기 로딩 속도가 빠르며, 웹 애플리케이션에서 클라이언트에서 처리하는 비즈니스 로직이 많을 경우 적합합니다.

반면에 SSR(Server-Side Rendering)은 서버에서 데이터를 처리하고, 처리된 데이터를 HTML로 렌더링하여 브라우저로 전송하는 방식입니다.

브라우저에서 서버로부터 HTML 파일을 요청하면 서버에서는 데이터를 처리하여 HTML로 렌더링하고, 이를 브라우저로 전송하여 화면에 렌더링합니다.

SSR 방식은 초기 로딩 속도가 느리지만, 검색 엔진 최적화(SEO)가 용이하고, 클라이언트에서 처리하는 비즈니스 로직이 적을 경우 유리합니다.

CSR과 SSR 모두 장단점이 있으며, 선택은 개발하고자 하는 웹 애플리케이션의 특성과 목적에 따라 다를 수 있습니다.

최근에는 두 방식을 혼합하여 사용하는 경우도 있으며, 이를 '최적화된 SSR'이라고 부르기도 합니다.

<br>

### SSR

렌더링이 서버측에서 이루어지는 방식을 말합니다.

1. 유저가 Website 요청을 보낸다.
2. 서버는 렌더링에 사용될 HTML 파일들을 생성하여 클라이언트로 전달한다.
3. 클라이언트는 받은 HTML 파일들을 우선 렌더링 하는데 보여지는 것만 가능하고 조작은 불가능하다.
4. 클라이언트는 JS파일을 다운로드한다.
5. 유저는 화면 내용을 볼 수 있고 유저의 조작들이 기록된다. (아직 실행X)
6. 클라이언트가 JS Framework를 실행시킨다.
7. 앞서 기록된 유저의 조작들이 실행되며, 이 시점부터 페이지의 정상적인 이용이 가능하다.

<br>

### CSR

렌더링이 클라이언트 측에서 이루어지는 방식을 말합니다.

1. 유저가 Website 요청을 보낸다.
2. CDN이 JS로 접근할 수 있는 HTML 파일들을 보낸다.
3. 클라이언트는 HTML과 JS를 다운로드한다.
4. JS가 실행되고, API를 호출하여 데이터를 요청한다.
5. 서버는 API로부터 요청에 데이터로 응답한다.
6. API로부터 도착한 데이터는 화면의 placeholder들을 채우고 이 시점부터 페이지의 정상적인 이용이 가능하다.

<br>

## 둘의 차이

### SSR 장점

- JS가 다운로드 되는 동안 사용자는 화면의 일정부분을 경험할 수 있다.
- 빠른 초기로딩
- 화면을 구성하는 각각의 페이지가 존재하기 때문에 SEO에 유리

<br>

### SSR 단점

- 빠른 초기 로딩으로 TTV(Time To View)와 TTI(Time TO Interact) 사이의 시간 간격이 생김
- 첫 페이지로딩은 빠르지만 이후 로딩들은 CSR보다 느린 속도를 가짐
- 추가 로딩시 화면 깜빡임 존재
- 화면 변경시 화면을 구성하는 모든 리소스들을 매번 다운로드 받아야함
- 매번 서버에 요청을 하기 때문에 서버의 많은 리소스들을 필요로 하여 서버에 부하를 준다.

<br>

### CSR 장점

- 첫 페이지 로딩은 느리지만 이후 로딩들은 SSR 보다 빠른 속도를 가짐.
- 추가 로딩시 화면 깜빡임 없음
- 화면 변경시 변경에 필요한 리소스들만 다운로드 받으면 됨.
- 서버에 부하가 적다.

<br>

### CSR 단점

- 한꺼번에 다운로드를 받기 때문에 그동안 사용자는 화면의 어떠한 부분도 경험할 수 없다.
- SSR과 비교하면 비교적 느린 초기 로딩
- SEO에 적합하지 않음. (JS까지 모두 다운 되어야 페이지가 로드되기 때문이다.)

<br>

## 어느 환경에서 사용하면 좋을까?

### SSR

- 한 번에 모든 파일을 다운로드 받을 필요가 없으므로 네트워크가 느린 곳
- 초기 로딩시에도 사용자의 경험을 우선시 할 때
- SEO를 신경 쓸 때
- 웹사이트에 동적인 컨텐츠가 많을 때

<br>

### CSR

- 한 번에 모든 파일을 다운로드 받으므로 네트워크가 빠른 곳
- 초기 로딩시 사용자의 경험을 비교적 덜 신경 쓸 때
- SEO를 신경쓰지 않을 때

<br>

## 📌 17. 회사 지원 동기를 말씀해주세요.

<br>

## 📌 18. 최근 경험했던 기억에 남는 에러에 대해 말씀해주세요.

<br>

## 📌 19. 요즘 공부하고 있는 것을 말씀해주세요.

<br>

## 📌 20. 자바스크립트를 공부하면서 가장 인상 깊었던 것을 말씀해주세요.

제너레이터(Generator)는 ES6(ECMAScript 2015)에서 도입된 함수입니다. 함수의 실행을 일시 중지하고 나중에 이어서 실행할 수 있는 기능을 제공합니다. 제너레이터를 이용하면 비동기적인 작업을 동기적으로 처리할 수 있으며, 이를 통해 코드의 가독성과 유지보수성을 높일 수 있습니다.

제너레이터 함수는 function\* 키워드를 사용하여 정의할 수 있습니다. 제너레이터 함수 내부에는 yield 키워드를 사용하여 값을 반환하고 함수의 실행을 일시 중지할 수 있습니다. next() 메서드를 호출하면 함수 실행을 이어서 진행할 수 있습니다.

제너레이터 함수는 제너레이터 객체를 반환하며, 제너레이터 객체는 next() 메서드를 가지고 있습니다. next() 메서드는 객체의 프로퍼티로 value와 done을 가지며, value는 yield 키워드에 의해 반환된 값이고, done은 함수의 실행이 끝났는지 여부를 나타냅니다.

제너레이터는 비동기 프로그래밍에서 많이 사용됩니다. 예를 들어, 데이터를 비동기적으로 가져온 후에 처리할 수 있도록 제너레이터를 활용할 수 있습니다. 이를 통해 비동기 코드의 가독성을 높이고 유지보수성을 높일 수 있습니다.

제너레이터를 사용하면 함수형 프로그래밍을 할 수 있습니다. 제너레이터 함수는 호출되면 실행 중인 컨텍스트를 유지하면서 제너레이터 이터레이터를 반환하고, 이터레이터는 next() 메서드를 사용하여 실행을 제어할 수 있습니다.

제너레이터를 사용하면 비동기 작업을 쉽게 처리할 수 있습니다. 예를 들어, 제너레이터를 사용하여 비동기 API 호출을 순차적으로 처리할 수 있습니다. 또한 제너레이터를 사용하여 무한한 시퀀스를 생성하거나 이터레이션 프로토콜을 구현할 수도 있습니다. 이는 함수형 프로그래밍에서 매우 유용합니다.

<br>
