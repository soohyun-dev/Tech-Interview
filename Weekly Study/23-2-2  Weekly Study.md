# 23년 2월 둘째주 Weekly Study

<br>

### 📜 목차

1. Flexbox와 Grid 각각의 특징에 대해 설명해주세요
2. 반응형 웹의 3요소에 대해 설명해주세요
3. CSS 적용 우선순위에 대해 설명해주세요
4. padding과 margin의 차이가 무엇인가요?
5. CSS-in-JS에 대해서 설명해주세요
6. px,em에 대해 설명해주세요
7. 리액트는 라이브러리인가요 프레임워크인가요?
8. 리액트를 사용하는 이유가 무엇인가요
9. virtual DOM에 대해서 설명해주세요
10. React에서 함수 컴포넌트와 클래스 컴포넌트의 차이에 대해 설명해주세요
11. props와 state의 차이에 대해 설명해주세요
12. props를 자식에서 부모로도 전달할 수 있을까요?
13. Flux에 대해 설명해주세요
14. 리덕스에 대해 설명해주세요
15. 리덕스의 기본 원칙은 무엇인가요?
16. useState에 대해 설명해주세요
17. useEffect에 대해 설명해주세요
18. useReducer에 대해 설명해주세요
19. useMemo에 대해 설명해주세요
20. useCallback에 대해 설명해주세요
21. useRef에 대해 설명해주세요

<br>

## 📌 1. Flexbox와 Grid 각각의 특징에 대해 설명해주세요

flex는 레이아웃을 좀 더 편하게 잡기 위해서 만들어진 css 속성입니다.

felx를 사용하면 요소들의 크기나 위치를 쉽게 잡을 수 있습니다.

기존에 수평 구조를 만들때 사용하는 속성이 float이나 inline-block 등이 있었지만,

여러가지 문제를 가지고 있었고 flex를 사용하면 이러한 속성의 한계를 보완할 수 있습니다.

물론 수평 뿐만 아니라 수직도 가능합니다.

정리하자면, flex를 사용하면 컨테이너와 아이템 개념을 이용하여 요소의 크기가 불분명하거나

동적인 경우에도 요소를 효율적으로 정렬할 수 있게 해줍니다.

float의 문제점 부모 요소가 자식 요소의 크기를 반영하지 못하는 문제점

<br>

grid를 사용하면 list에 width를 따로 입력 하지 않고 리스트에 간격과 width 비율만 입력해주면 쉽고 간편히 만들 수 있습니다.

또 추가적으로 브라우저 창을 줄여도 자동으로 리스트의 width가 퍼센트를 준 것 처럼 브라우저 창에 반응하는것을 볼 수 있습니다.

<br>

## 📌 2. 반응형 웹의 3요소에 대해 설명해주세요

### 1. grid layout

부모요소에 display: grid; 속성을 넣어준다.
<br>

### 2. 가변형 이미지

max width, width, min-width 등을 이용해 화면 너비에 따라 높이와 너비가 바뀌는 이미지

<br>

### 3. 미디어 쿼리

미디어 쿼리는 화면, 티비, 프린터와 같이 미디어 타입과 적어도 하나 이상의 표현식으로 구성된다.

표현식은 width, height, color와 같은 미디어 특성들을 이용하여 그 특성들의 상태에 따라 다른 스타일 시트를 적용할 수 있다.

미디어 쿼리는 CSS3에 포함되어 있으며, 컨텐츠의 변경없이 주로 화면의 크기에 따라 스타일 시트를 달리하여 적절한 모양을 보여줄 수 있다.

<br>

## 📌 3. CSS 적용 우선순위에 대해 설명해주세요

(1) 모두 같은 우선순위에 있는 경우 기본적으로는 나중에 선언한 css가 우선순위가 높습니다.

(2)

1. !important
2. inline style attribute
3. id
4. class, 다른 attribute, 수도클래스(:first-child 같은 것)
5. tag element, 수도 엘리멘트(::before 같은 것)
6. 상위 객체에 의해 상속된 속성

<br>

## 📌 4. padding과 margin의 차이가 무엇인가요?

padding 대상의 내부 여백을 나타내며, margin은 대상의 외부 여백을 나타냅니다.

<br>

## 📌 5. CSS-in-JS에 대해서 설명해주세요

CSS-in-JS는 CSS 모델을 문서 레벨이 아니라 컴포넌트 레벨로 추상화한다. (모듈성)

따라서 Css-in-JS를 사용하면 컴포넌트 단위로 생각할 수 있다.

진정한 분리 법칙을 따른다. CSS에는 명시적으로 정의하지 않은 경우, 부모 요소에서 자동으로 상속되는 속성이 있다.

CSS-in-JS의 경우 부모 요소의 속성을 상속하지 않는다.

대표적인 라이브러리로 styled-components와 emotion이 있다.

<br>

### 추가 질문

styled-components와 emotion을 사용해보셨나요? 느낀점을 말해주세요.

- 컴포넌트 레벨로 추상화하기 때문에 단일 파일에서 관리하기 용이합니다. 또한 JavaScript의 코드를 활용할 수 있어 좋습니다.

다만, 별도의 라이브러리가 필요해서 크기가 커질 수 있고, 디자인 페이지를 작업한다면 CSS 모듈 방식에 비해 느린 성능을 보여줄 수 있습니다.

<br>

## 📌 6. px,em에 대해 설명해주세요

<pre>
px는 `모니터에 따라 상대적인 크기`를 가집니다.
따라서 반응형 웹에는 적절하지 않습니다.

em은 같은 요소에서 지정된 font-size 값을 기준으로 px로 변환됩니다.

같은 엘리먼트에 설정된 font-size 값이 없을 경우 상위 요소의 font-size 값이 기준이 됩니다.

rem은 최상위 요소의 font-size 값을 기준으로 변환됩니다.

rem은 기준이 되는 폰트 크기 하나로 고정되어 있는 반면, 
em은 같은 엘리먼트는 어디서라도 그 기준이 바뀌기 때문에 
복잡한 css를 가질 경우 변환될 크기를 예측하기 어렵다는 단점이 있습니다.
</pre>

<br>

## 📌 7. 리액트는 라이브러리인가요 프레임워크인가요?

### 프레임워크

- 정해진 규칙에 맞게 코드를 작성해야한다.
- 파일 이름, 구조 등을 정해진 규칙에 따라야한다.
- 일정한 형태와 필요한 기능들을 갖추고 있다.

프레임워크는 Application 개발시 코드의 품질, 필수적인 코드, 알고리즘, 암호화, 데이터베이스 연동 같은 기능들을 어느정도 구성이 되어있는 뼈대(구조)를 제공하도록 만들어진 것입니다.

개발 구조나 설계 시 제공되는 인터페이스의 집합입니다.
개발자는 제공된 프레임워크의 구조에서 어플리케이션을 개발해야합니다.

ex) Next.js

<br>

### 라이브러리

- 사용자가 어떠한 프로그램을 가져와 사용한다.
- 사용자가 파일 이름, 구조 등을 정하고 모든 결정을 내린다.

라이브러리는 특정 기능에 대한 API(도구 / 함수)를 모은 집합을 말합니다.

특정 기능을 사용하기 위해 불러와서 호출하는 방식을 생각하시면 됩니다.

ex) React.js

<br>

### 둘의 차이

프레임워크와 라이브러리의 가장 중요한 차이점은 Inversion of Control(통제의 역전)입니다.

프레임워크는 정해진 틀 내에서 수동적으로 동작하지만, 라이브러리는 코드의 흐름을 직접 제어합니다.

<br>

## 📌 8. 리액트를 사용하는 이유가 무엇인가요

1. 컴포넌트 기반의 화면 구성

리액트는 화면의 한 부분을 컴포넌트라는 단위로 나눌 수 있으며, 독립적으로 관리할 수 있다. 대규모 웹 애플리케이션에서 컴포넌트는 역할과 기능에 따라 따로 관리하기 용이하며, 반복되는 부분을 대체할 수 있게 해주어서 코드 재사용성을 높여주거나, 컴포넌트 기반의 화면을 구성할 때 블록 쌓기 처럼 컴포넌트를 쌓아서 빠르고 효율적으로 화면을 구성할 수 있다.

<br>

2. Virtulal DOM으로 인한 충분히 빠른 속도

Virtual DOM은 UI의 이상적인 또는 가상적인 표현을 메모리에 저장하고 ReactDOM과 같은 라이브러리에 의해 '실제' DOM과 동기화하는 프로그래밍 개념입니다. 이 과정을 재조정이라고 합니다. 이 접근 방식이 React의 선언적 API를 가능하게 합니다. React에게 원하는 UI의 상태를 알려주면 DOM이 그 상태와 일치하도록 합니다. 이러한 방식은 앱 구축에 사용해야 하는 어트리뷰트 조작, 이벤트 처리, 수동 DOM 업데이트를 추상화 합니다.

<br>

3. SPA

장점

- 서버의 자원을 아낄 수 있다.
- 더 좋은 사용자 경험을 누릴 수 있다.

단점

- 사용자와 인터렉션이 많은 경우에는 서버의 자원이 많이 사용되고 불필요한 트래픽이 낭비 될 수 있다.

<br>

정리하자면,

- component를 사용해서 유지보수가 용이하다. (필요한 부분의 component만 렌더링 된다.)
- 생태계가 넓고, 다양한 라이브러리를 사용할 수 있다.
- virtual DOM을 활용하여 빠른 렌더링이 가능하다.
- 리액트 네이티브를 활용하여 앱 개발이 가능하다.

<br>

## 📌 9. virtual DOM에 대해서 설명해주세요

DOM은 XML이나 HTML 문서에 접근하기 위한 일종의 인터페이스다.
DOM은 문서의 구조화된 표현을 제공하며 프로그래밍 언어가 DOM구조에 접근할 수 있는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 변경할 수 있게 돕는다.

```
HTTP response > DOM Tree > CSSOM Tree > render Tree > painting
```

DOM은 새로운 요청이 있으면 위와 같은 형태를 거쳐 리렌더링을 하게 된다. DOM의 속도는 느리지 않지만, 매번 새롭게 구성하기 때문에, 양이 엄청 많으면 분명 수행시간이 길어질 것이다. 여기서 virtual DOM의 장점이 나오게 된다.

리액트는 Virtual DOM을 사용하여 실제 DOM에 접근하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용합니다. 마치 실제 DOM의 가벼운 사본과 비슷합니다.

리액트에서 데이터가 변하여 웹 브라우저에 실제 DOM을 업데이트할 때는 다음 세 가지 절차를 밟습니다.

1. 전체 UI를 Virtual DOM에 리렌더링

2. 이전 내용과 현재 내용을 비교

3. 바뀐 부분만 실제 DOM에 적용

Virtual DOM을 사용한다고 해서 사용하지 않을 때와 비교하여 무조건 빠른 것은 아닙니다. 적절한 곳에 사용해야 리액트가 지닌 진가를 발휘할 수 있습니다.

리액트와 Virutal DOM이 언제나 제공할 수 있는 것은 바로 업데이트 처리 간결성입니다. UI를 업데이트 하는 과정에서 생기는 복잡함을 모두 해소하고 더욱 쉽게 업데이트에 접근할 수 있습니다.

<br>

## 📌 10. React에서 함수 컴포넌트와 클래스 컴포넌트의 차이에 대해 설명해주세요

### 클래스 컴포넌트

- 객체지향 프로그래밍 구조를 띄고 있으며, state를 초기화하기 위해서는 constructor (생성자) 함수를 필요로 합니다.

- 생성자 함수를 통해 state를 초기화해야 하기 때문에 함수 컴포넌트에 비해서 코드가 길어지고, 사이즈가 커질 수 있습니다.

- state 기능 및 라이프 사이클 기능을 사용할 수 있으며, 임의 메서드를 정의할 수 있습니다.

- render 함수가 꼭 있어야 하고, 그 안에서 보여 주어야 할 JSX를 반환해야 합니다.

<br>

### 함수 컴포넌트

- Hooks를 사용하여 생성자 함수를 통해 state를 초기화하지 않더라도 사용이 가능합니다. (useState 등)

- 선언하기가 좀 더 편하고 메모리 지원을 덜 사용한다는 장점이 있습니다.

- 제공되는 hook 함수 뿐만 아니라 커스텀 훅을 생성하여 동작시킬 수 있습니다.

- 프로젝트를 완성하여 빌드한 후 배포할 때도 함수 컴포넌트를 사용하는 것이 결과물의 파일 크기가 더 작습니다.

<br>

초기 함수형 컴포넌트는 state와 라이프 사이클 API 사용이 불가능했지만, v16.8 업데이트 이후에 적용된 Hooks를 통해 해결이 되었습니다.

<br>

## 📌 11. props와 state의 차이에 대해 설명해주세요

### props

컴포넌트 속성을 설정할 때 사용하는 요소이다.

props 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서 설정할 수 있다.

자식에서는 readonly

### state

컴포넌트 내부에서 바뀔 수 있는 값을 의미한다.

<br>

props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값이며, 컴포넌트 자신은 해당 props를 읽기 전용으로만 사용할 수 있습니다.
props를 바꾸려면 부모 컴포넌트에서 바꿔줘야 합니다.

<br>

## 📌 12. props를 자식에서 부모로도 전달할 수 있을까요?

1. 부모 컴포넌트에서 설정할 수 있으며, 부모에서 자식으로만 데이터를 줄 수 있다. (자식이 props를 통해 부모에게 줄 수 없다는 뜻이다.)

2. 자식에게 부모로 데이터를 전달하려면 함수를 이용해야한다.

- 자식은 props를 사용해서 부모에게 데이터를 건네줄 수 없다. 따라서 부모가 함수를 넣어 props로 자식에게 넘겨주면, 자식이 데이터를 파라미터로 넣어 호출하는 방식으로 동작한다. 즉, 부모가 props로 함수를 넣어주면 자식이 그 함수를 이용해 값을 건네주는 방식이다.

<br>

요약하면, props를 자식에서 부모로 직접 전달하는 것은 불가능하고 부모로부터 건네 받은 함수를 이용해서 호출해 전달하는 식으로 해야한다.

<br>

## 📌 13. Flux에 대해 설명해주세요

FLUX는 라이브러리나 프레임워크가 아닌 추상적인 개념입니다.

MVC 패턴에서 양방향적인 데이터 흐름을 강조했던 것과 달리 FLUX 패턴에서는 단방향 데이터 흐름을 강조합니다.

MVC 패턴의 경우 사용자의 어떠한 행위(액션)이 있을 때, 이를 바탕으로 설계된 컨트롤러를 통해 모델을 변화하고 이를 뷰에 반영합니다.

하지만, 모델과 뷰가 복잡하게 얽혀 있다면 어떤 모델이 변화되어 뷰가 변경되었는지 제대로 확인할 수 없는 경우가 생깁니다.

이를 해결하기 위해 나온 단방향 데이터 흐름을 제어하는 패턴이 FLUX 입니다.

사용자의 행위 액션은 디스패쳐에 의해 통제됩니다.

dispatch가 store를 업데이트하고 변경된 store에 대한 view를 리렌더링합니다.

view에서는 store에 직접 접근하지 않으며, dispatch로 다시 액션을 보내고 store를 업데이트한 뒤, 다시 뷰를 리렌더링하는 단방향적 구조를 가집니다.

FLUX 패턴은 이러한 단방향적인 데이터 흐름 구조를 통해 어떤 액션이 디스패처에 의해 어떤 결과를 낳고 변화되는지 명확히 파악하고 알아 볼 수 있습니다.

<br>

## 📌 14. 리덕스에 대해 설명해주세요

리덕스는 상태관리 라이브러리 중 하나로 여러 가지 상태관리 라이브러리 중 가장 많이 사용되고 있습니다.

리덕스는 Store라는 변수를 이용하여 전역 상태관리를 하게 됩니다.

전역으로 상태를 관리하기 때문에 props <-> state를 통해 부모 컴포넌트에서 자식 컴포넌트로, 자식의 자식 컴포넌트로 내려주지 않아도 사용할 수 있습니다.

<br>

## 📌 15. 리덕스의 기본 원칙은 무엇인가요?

1. Sigle source of truth

- 동일한 데이터는 store라는 하나뿐인 데이터 공간에서 가지고 와서 사용한다.

<br>

2. State is read-only

- state 변경은 reducer에서만 가능하며, 이외의 공간에서는 read-only로 읽기만 가능하다.

<br>

3. Changes are made with pure functions

- 변경을 일으키는 reducer는 순수 함수여야 한다.
- 즉, 동일한 파라미터에는 동일한 결과값을 반환해야 한다.

<br>

## 📌 16. useState에 대해 설명해주세요

```javascript
const [data, setData] = useState("");
```

- 첫 번째 원소는 상태 값, 두 번째 원소는 상태를 설정하는 함수인 튜플 형태입니다.
- 함수에 파라미터를 넣어서 호출하면 전달받은 파라미터로 값이 바뀌고 컴포넌트가 정상적으로 리렌더링 됩니다.

<br>

## 📌 17. useEffect에 대해 설명해주세요

리액트 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정할 수 있는 Hook입니다.

클래스형 컴포넌트의 componentDidMount와 componentDidUpdate,componentWillUnmount 를 합친 형태로 보아도 무방합니다.

- 마운트만 실행시키고 싶은 경우
  두 번째 파라미터로 비어있는 배열을 넣어준다.

```javascript
useEffect(() => {
  console.log("마운트될 때만 실행");
}, []);
```

<br>

- 특정 값이 업데이트될 때만 실행하고 싶은 경우
  두 번째 파라미터로 전달되는 배열 안에 검사하고 싶은 값을 넣어준다.

```javascript
useEffect(() => {
  console.log(data);
}, [data]);
```

<br>

useEffect는 기본적으로 렌더링되고 난 직후마다 실행되며, 두 번째 파라미터 배열에 무엇을 넣는지에 따라 실행되는 조건이 달라집니다.

컴포넌트가 언마운트되기 전이나 업데이트되기 직전에 어떠한 작업을 수행하고 싶다면 useEffect에서 cleanup 함수를 반환해줘야 합니다.

return 문 내에 작성하며, 언마운트 시에 작업할 코드를 넣어주면 됩니다.

```javascript
useEffect(() => {
  console.log("렌더링이 완료");
  return () => {
    console.log("언마운트 완료!");
  };
});
```

<br>

## 📌 18. useReducer에 대해 설명해주세요

useReducer는 useState보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트해 주고 싶을 때 사용하는 hook입니다. 리듀서는 현재 상태, 그리고 업데이트를 위해 필요한 정보를 담은 액션 값을 전달받아 새로운 상태에 반환하는 함수입니다. 리듀서 함수에서 새로운 상태를 만들 때는 반드시 불변성을 지켜주어야 합니다.

<br>

## 📌 19. useMemo에 대해 설명해주세요

useMemo를 사용하면 함수 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있습니다.

렌더링 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 원하는 값이 바뀌지 않았다면, 이전에 연산했던 결과를 다시 사용하는 방식입니다.

- 메모이제이션

계산된 값을 자료구조에 저장하고 이후 같은 계산을 반복하지 않고 자료구조에서 재사용하는 것을 말한다.

<br>

## 📌 20. useCallback에 대해 설명해주세요

useMemo와 상당히 비슷한 함수입니다. 주로 렌더링 성능을 최적화 해야하는 상황에서 사용합니다. useCallback을 사용하면 만들어놨던 함수를 재사용할 수 있습니다. useCallback의 첫 번째 파라미터에는 생성하고 싶은 함수를 넣고, 두 번째 파라미터에는 배열을 넣으면 됩니다. 이 배열에는 어떤 값이 바뀌었을 때 함수를 새로 생성해야 하는지 명시해야 합니다.

```javascript
const onChange = useCallback((e) => {
  setNumber(e.target.value);
}, []); // 컴포넌트가 처음 렌더링될 때만 함수 생성


const onInsert = useCallback(
  (e) => {
    const nextList = list.concat(parseInt(number));
    setList(nextList);
    setNumber("");
  },
  [number, list] // number 혹은 list가 바뀌었을 때만 함수 생성
);

// 위아래는 서로 동일한 기능을 수행하는 코드이다.

useMemo(() => {
  const fn = () => {
    console.log(‘hello world!‘);
  };
  return fn;
}, [])
```

- 함수 내부에서 상태 값에 의존해야 할 때는 그 값을 반드시 두 번째 파라미터 안에 포함시켜줘야 합니다. ex) onInsert 함수의 number 와 list

`useMemo`가 특정 결과값을 재사용 할 때 사용한다면, `useCallback`은 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용한다.

<br>

## 📌 21. useRef에 대해 설명해주세요

바닐라 자바스크립트에서 DOM 요소를 조작하기 위해 querySelector나 getElementById 등을 사용했다면, 리액트에서는 useRef 훅 함수를 사용합니다.

useRef는 .current 프로퍼티에 변경가능한 값을 담고 있느 객체입니다.

.current 프로퍼티를 변경하더라도 리렌더링을 유발하지 않습니다.

ref 객체 안의 값은 리액트 생명주기에 독립적이기 때문입니다.

<br>

React에서 state로만 해결할 수 없고, DOM을 반드시 직접 건드려야할 때 사용합니다.

- 포커스, 텍스트 선택영역, 혹은 미디어의 재생을 관리할 때
- 애니메이션을 직접적으로 실행시킬 때
- 서드 파티 DOM 라이브러리를 React와 같이 사용할 때

위의 경우들이 아닌 선언적으로 해결될 수 있는 문제들에선 Ref사용을 지양한다.
