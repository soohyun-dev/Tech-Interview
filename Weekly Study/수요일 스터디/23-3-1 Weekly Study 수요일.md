# 23년 3월 첫째주 Weekly Study

<br>

### 📜 목차

1. 브라우저의 렌더링 원리에 대해 설명해주세요.
2. Reflow와 Repaint가 실행되는 시점에 대해 말씀해주세요.
3. 주소창에 google.com을 입력하면 일어나는 일에 대해 말씀해주세요.
4. 호이스팅에 대해서 설명해주세요.
5. 클로저에 대해서 설명해주세요.
6. CSS에서 margin과 padding에 대해서 설명해주세요.
7. CSS에서 position을 어떻게 사용하는지 설명해주세요.
8. REST API란 무엇인지 설명해주세요
9. this의 용법에 대해 아는대로 설명해주세요.
10. 브라우저 저장소의 차이점에 대해 설명해주세요. (LocalStorage,SessionStorage,Cookie)
11. Restful API에 대해 아는대로 설명해주세요. (GET, PUT, POST, PATCH, OPTION, DELETE)
12. JavaScript는 어떤 언어인가요?
13. JavaScript에서 비동기적으로 코딩하는 법을 알려주세요.
14. Event Loop에 대해 알고 있으신가요?
15. 마이크로태스크 큐와 태스크 큐에 대해서 말씀해주세요.
16. 이벤트 버블링에 대해서 말씀해주세요.
17. 타입 스크리트 사용해 본적이 있나요? 어떤지 말씀해주세요.
18. 실행 컨텍스트에 대해서 설명해주세요.
19. SPA, CSR, SSR의 차이에 대해 설명해주세요.
20. null, undefined, undeclared, NaN 에 대해 설명해주세요.

<br>

## 📌 1. 브라우저의 렌더링 원리에 대해 설명해주세요

1. 사용자가 웹브라우저에 접속함.
2. 웹브라우저는 DNS 에게 host 의 ip 주소를 받아옴
3. ip 주소에 있는 서버를 찾아가
4. 서버와 브라우저는 3 Way-Handshake 를 실행함
5. 이후 브라우저는 서버에게 데이터( HTML, CSS, JS, 이미지, 폰트 파일 등 렌더링에 필요한 리소스)를 요청함. **(HTTP Request)**
6. 서버는 브라우저에게 데이터를 보내줌 **(HTTP Response)**
7. 브라우저는 서버로부터 받은 데이터를 해석함 (Parsing)
8. 브라우저의 렌더링 엔진은 HTML을 파싱하여 DOM Tree 를 생성함.
9. 이때, 렌더링 엔진이 style 태그를 만난다면 HTML 파싱을 중지하고 CSS 파싱 작업을 시작하여 CSSOM Tree를 생성.
10. CSS파싱을 마치면 HTML 파싱이 중단된 시점부터 다시 파싱 시작
11. 그러다가 scirpt 태그를 만나면 파싱을 중지하고 자바스크립트 엔진에게 제어 권한을 넘김
12. JS엔진은 코드를 해석하고 추상구문 Tree 인 AST(Abstract Syntax Tree)를 생성하고 실행한다.
13. 중단했던 HTML 파싱을 완료함.
14. DOM Tree + CSSOM Tree = Render Tree // **여기까지가 Construction**
15. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다.
16. UI Backend가 Render Tree의 노드들을 돌면서 UI 를 그림
17. 노드들의 레이어를 순서대로 구성하는 **Composition 단계** **layout~composition = Operation**
18. 최종적으로 사용자에게 화면 출력
    <br/>

## 📌 2. Reflow와 Repaint가 실행되는 시점에 대해 말씀해주세요.

### Reflow

- 생성된 DOM 노드의 레이아웃 수치 변경 시 영향 받은 모든노드의 수치를 다시 계산하여, 렌더 트리를 재생성하는 과정

실행되는 시점

- DOM요소의 기하학적 속성이 변경될 때, 브라우저 사이즈가 변할 때, 스타일시트가 로딩되었을 때

<br/>

### Repaint

- Reflow 과정이 끝난후 재 생성된 렌더 트리를 다시 그리는 과정. 변경된 요소를 실제로 화면에 그려주는 작업이다. 리플로우가 일어나면 리페인트는 필연적으로 실행된다.

실행되는 시점

- Reflow가 발생했을 때
- 배경색이나 visibility 속성이 변했을 때

<br/>

## 📌 3. 주소창에 google.com을 입력하면 일어나는 일에 대해 말씀해주세요.

1. 사용자가 웹 브라우저를 통해 google.com 을 입력하면 URL 주소 중 도메인 네임 부분을 DNS 서버에서 검색합니다.
2. DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달합니다.
3. 브라우저는 HTTP 프로토콜을 사용하여 요청 메시지를 생성하고 HTTP 요청 메시지는 TCP/IP 프로토콜을 사용하여 서버로 전송됩니다.
4. 서버는 response 메시지를 생성하여 다시 브라우저에게 데이터를 전송합니다.
5. 브라우저는 response를 받아 파싱하여 화면에 렌더링합니다.

<br/>

## 📌 4. 호이스팅에 대해서 설명해주세요.

JS엔진은 모든 선언문을 소스코드의 위치에 상관 없이 다른 코드들보다 먼저 실행합니다.

런타임 이전에 실행 컨텍스트에 의해 소스코드 평가 과정에서 스코프에 등록되어 마치 코드의 제일 상단으로 끌어올려진 것과 같은 효과를 불러와

변수가 어디에 선언 되었든 변수를 참조할 수 있게 만드는 특징을 호이스팅이라고 합니다.

var, let, const 뿐만 아니라 function, class 키워드를 사용하여 선언하는 모든 식별자들은 호이스팅 됩니다.

이러한 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문입니다.

<br>

## 📌 5. 클로저에 대해서 설명해주세요.

클로저는 두 가지로 설명할 수 있다.

- 자신이 선언될 당시의 환경을 기억하는 함수.
- 함수와 그 함수가 선언된 렉시컬 환경의 조합.

해당 함수의 생명 주기가 종료되더라도 함수의 반환된 값이 변수에 의해 아직 참조되고 있다면 생명 주기가 종료되더라도 렉시컬 환경에 남아 참조가 가능하다.

클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.

다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.

```javascript
<script>
     function foo() {
       const x = 1;
       const y = 2;

       // 클로저
       // 중첩 함수 bar는 외부 함수보다 더 오래 유지되며 상위 스코프의 식별자를 참조한다.
       function bar() {
         debugger;
         console.log(x);
       }
       return bar;
     }

     const bar = foo();
     bar();
   </script>
```

<br>

## 📌 6. CSS에서 margin과 padding에 대해서 설명해주세요.

padding 대상의 내부 여백을 나타내며, margin은 대상의 외부 여백을 나타냅니다.

<br>

## 📌 7. CSS에서 position을 어떻게 사용하는지 설명해주세요.

position 속성은 문서 상에 요소를 배치하는 방법을 지정합니다.

- static: 요소를 일반적인 문서 흐름에 따라 배치합니다.

- relative: static + 자신을 기준으로 top, right, bottom, left의 값에 따라 오프셋을 적용합니다.

- absolute: 요소를 일반적인 문서 흐름에서 제거하고, 가장 가까운 위치 지정 조상 요소에 대해 상대적으로 배치합니다.

- fixed: 요소를 일반적인 문서 흐름에서 제거하고, 뷰포트의 초기 컨테이닝블록을 기준으로 삼아 배치합니다. => 바뀌지 않는 위치에 지정

- sticky: static + fixed 특징을 동시에 가집니다.

<br>

#### static

- 기본값으로 요소들이 겹치지 않고 상->하로 배치된다.

<br>

#### relative

- 원래 배치되어야 할 위치에서 지정된 값만큼 떨어진 곳에 요소를 배치한다.

<br>

#### fixed

- 웹 브라우저 화면 전체를 기준으로 배치한다. 스크롤을 하더라도 위치가 고정된다.

<br>

#### absolute

- 가장 가까운 상위 요소의 위치를 기준으로 지정한 값 만큼 떨어진 곳에 요소를 배치한다.

<br>

#### sticky

- 스크롤 위치가 임계점에 이르면 position: fixed와 같이 박스를 화면에 고정할 수 있는 속성으로, 스크롤 영역 기준으로 배치한다.

<br>

## 📌 8. REST API란 무엇인지 설명해주세요

REST는 HTTP의 장점을 최대한 활용할 수 있는 아키텍처로서, HTTP 프로토콜을 의도에 맞게 디자인하도록 유도합니다.

HTTP URI를 통해 자원을 명시하고 HTTP 메서드(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD를 적용하는 것을 말합니다.

즉, REST는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍쳐고, REST API는 REST를 기반으로 서비스 API를 구현한 것을 의미한다.

REST의 기본 원칙을 성실히 지킨 서비스 디자인을 `RESTful`이라고 표현한다.

<br>

### API란 무엇인가?

응용프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스입니다.

여러 프로그램들과 데이터베이스, 그리고 기능들의 상호 통신 방법을 규정하고 도와주는 매개체이며, 쉽게 말해 프로그램끼리 통신할 수 있도록 하는 중재자역할을 합니다.

<br>

## 📌 9. this의 용법에 대해 아는대로 설명해주세요.

this는 호출 패턴에 따라 다른 객체를 참조합니다.

실행 컨텍스트가 생성될 때마다 this의 바인딩이 일어나며 this 바인딩의 예는 다음과 같습니다.

1. new 를 사용했을 때 해당 객체로 바인딩됩니다.

2. call, apply, bind 와 같은 명시적 바인딩을 사용했을 때 인자로 전달된 객체에 바인딩됩니다.

3. 객체의 메소드로 호출할 경우 해당 객체에 바인딩됩니다.

4. 일반함수나 전역의 경우

- 일반: 브라우저라면 window 객체에 바인딩됩니다.
- strict mode(엄격 모드): undefined 로 초기화됩니다.

<br>

## 📌 10. 브라우저 저장소의 차이점에 대해 설명해주세요. (LocalStorage,SessionStorage,Cookie)

### LocalStorage

로컬 스토리지는 저장한 데이터를 지우지 않는 이상 영구적으로 보관이 가능합니다.

도메인마다 별도의 로컬 스토리지가 생성됩니다.

데이터 범위에서 세션 스토리지와 차이가 있는데 로컬 스토리지는 동일한 도메인이라면 전역적으로 데이터가 공유되어지지만,

세션 스토리지는 도메인이 같더라도 브라우저가 다르면 브라우저 컨텍스트가 다르기 때문에 각각의 세션 스토리지가 생성되어 데이터 공유가 되지 않습니다.

ex) 자동 로그인

<br>

### SessionStorage

세션 종료 시 클라이언트에 대한 정보가 삭제됩니다.

ex) 입력 폼, 비로그인 장바구니

<br>

### Cookie

HTTP의 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일입니다.

HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장하였다가 필요시 정보를 참조하거나 재사용할 수 있습니다.

다만, 웹 스토리지와 달리 웹 사이트에서 쿠키를 설정하면 모든 웹 요청에는 쿠키 정보가 포함되기 때문에 네트워크 트래픽이 증가를 유발하게 됩니다.

ex) 팝업 창

<br>

## 📌 11. Restful API에 대해 아는대로 설명해주세요. (GET, PUT, POST, PATCH, OPTION, DELETE)

두 컴퓨터 시스템이 인터넷을 통해 정보를 안전하게 교환하기 위해 사용하는 인터페이스입니다.

- GET: 요청받은 URI의 정보를 검색하여 응답합니다.
- POST: 요청된 자원을 생성합니다.
- DELETE: 요청된 자원을 삭제할 것을 요청합니다.
- PUT: 요청된 자원을 (전체를) 수정합니다.
- PATCH: 요청된 자원 (일부를) 수정합니다.

- HEAD: GET 방식과 동일, 하지만 응답에 BODY가 존재하지 않으며, 응답코드와 HEAD 만 응답합니다.
- CONNECT: 동적으로 터널모드를 교환, 프록시 기능을 요청시 사용합니다.
- TRACE: 원격지 서버에 루프백 메세지를 호출하기 위해 테스트용으로 사용합니다.
- OPTIONS: 웹서버에서 지원되는 메서드의 종류를 확인할 경우 사용합니다.

<br/>

## 📌 12. JavaScript는 어떤 언어인가요?

자바스크립트는 인터프리터 언어이면서 명령형, 함수형, 프로토타입 기반 객체 지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어입니다.

또한, 싱글 스레드이지만 비동기처리를 통해 여러 다른 작업을 동시에 처리하는 것과 같이 보이게 만드는 논 블로킹 방식의 비동기적인 동시성 언어입니다.

<br>

## 📌 13. JavaScript에서 비동기적으로 코딩하는 법을 알려주세요.

- 콜백 함수
- Promise
- async/await

자바스크립트에서는 비동기 처리를 위한 패턴중 하나로 콜백 함수를 사용합니다.

전통적인 콜백 패턴은 '콜백 헬'로 인해 가독성이 나쁘고 비동기 처리 중 발생한 에러의 처리가 곤란하며 여러 개의 비동기 처리를 한 번에 처리하는데 한계가 있습니다.

ES6에서 도입된 프로미스는, 이러한 콜백 함수의 문제점인 비동기 처리를 해결하기 위한 또 하나의 패턴입니다.

프로미스는 호스트 객체가 아닌 ECMAScript 사양에 정의된 표준 빌트인 객체입니다.

비동기 처리를 수행할 콜백 함수를 인수로 전달 받는데 이 콜백 함수는 resolve와 reject 함수를 인수로 전달받습니다.

Promise 생성자 함수가 인수로 전달받은 콜백 함수 내부에서 비동기 처리를 수행합니다. 이때 비동기 처리가 성공하면 resolve를, 실패하면 reject를 호출합니다.

<br>

ES8에서는 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기 처리처럼 동작할도록 구현할 수 있는 async/await가 도입되었다.

async/await는 프로미스를 기반으로 동작하기 때문에 프로미스의 then/catch/finally 등의 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기 처리처럼 프로미스를 사용할 수 있다.

즉, 프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 다시 반환할 수 있도록 구현할 수 있다.

async await 으로 구현할 경우 제너레이터의 성질을 갖기 때문에 항상 프로미스가 setteled(이행된) 상태가 될 때까지 대기한다.

따라서, 모든 코드에 async await을 남발하는 것은 도움이 되지 않는다.

<br>

## 📌 14. Event Loop에 대해 알고 있으신가요?

이벤트 루프란 자바스크립트 엔진이 아닌, 구동하는 환경(브라우저, 노드)에서 가지고 있는 장치입니다.

이 이벤트루프를 통해 자바스크립트의 동시성을 지원하게 됩니다.

콜 스택과 태스크 큐(=콜백 큐)를 감시하며, 콜 스택이 비어있을 경우에 FIFO 방식으로 태스크 큐에서 태스크(=콜백함수)를 가져와 콜 스택에 넣어 실행시키는 기능을 한다.

이벤트 루프에는 window event loop, worker event loop, worklet event loop 세 가지 종류가 있다.

<br>

비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당한다.

<br>

## 📌 15. 마이크로태스크 큐와 태스크 큐에 대해서 말씀해주세요.

마이크로태스크 큐는 태스크큐와 별도의 큐로 후속 처리 메서드의 콜백 함수가 일시 저장된다.

그 외의 비동기 함수 setTimeout/setInterval 이나 HTTP 요청, 이벤트 핸들러나 이벤트 핸들러의 콜백 함수는 테스크 큐에 일시 저장됩니다.

콜백 함수나 이벤트 핸들러를 일시 저장한다는 점에서 태스크 큐와 동일하지만 마이크로테스크 큐는 태스크 큐보다 우선순위가 높다.

<br>

### 태스크 큐와 마이크로태스크 큐 중 어떤 것이 먼저 실행되나요? 🔥

이벤트 루프는 마이크로태스크 큐의 모든 태스크들을 처리한 다음, 테스크 큐의 테스크들을 처리한다. <br>
따라서, 마이크로태스크 큐가 먼저 실행된다.

<br>

## 📌 16. 이벤트 버블링에 대해서 말씀해주세요.

DOM 트리상에 존재하는 모든 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파됩니다. 이를 이벤트 전파라고 합니다.

사용자의 다양한 입력을 통해 동적으로 생성되는 이벤트 객체는 이벤트를 발생시킨 타깃을 중심으로 DOM 트리를 통해 전파됩니다.

전파되는 방향에 따라 3단계로 구분할 수 있습니다.

- 캡쳐링 단계 : 이벤트가 상위 요소에서 하위 요소 방향으로 전파
- 타깃 단계 : 이벤트가 이벤트 타깃에 도달
- 버블링 단계 : 이벤트가 하위 요소에서 상위 요소 방향으로 전파

브라우저는 기본적으로 버블링 단계에서 이벤트를 캐치합니다.

`addEventListener` 메서드의 세번째 인수로 옵션인 [, useCapture] 자리에 true 를 넣어주면 캡쳐링 단계에서도 이벤트 객체를 캐치할 수 있다.

기본 값은 false로 버블링 단계에서 캐치를 한다.

<br>

### 이벤트 위임(delegation)이란?

캡쳐링과 버블링을 이용한 것으로, 여러 엘리먼트마다 각각 이벤트 핸들러를 할당하지 않고, 공통되는 부모에 이벤트 핸들러를 할당하여 이벤트를 관리하는 방식.

연속되는 태그에 대해서 공통적으로 이벤트를 줘야할 때 우리가 이벤트 핸들러를 바인딩할 요소의 부모 요소에게 이를 위임하여 이벤트를 진행하는 것을 말합니다.

<br>

## 📌 17. 타입 스크립트 사용해 본적이 있나요? 어떤지 말씀해주세요.

타입을 명시하지 않는 자바스크립트와 달리, 타입스크립트를 통해 정적 타입을 명시하여 사용할 수 있습니다.

### 타입스크립트의 장점

타입스크립트는 코드에 목적을 명시하고, 목적에 맞지 않는 타입의 변수나 함수들에서 에러를 발생시켜 버그를 사전에 제거할 수 있습니다.

프로젝트가 크고, 복잡할수록 타입스크립트가 가진 강점이 점점 더 강해집니다.

<br>

## 📌 18. 실행 컨텍스트에 대해서 설명해주세요.

실행 컨텍스트는 소스 코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역입니다.

식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.

<br>

실행 컨텍스트는 1. 실행 컨텍스트 스택과 2. 렉시컬 환경으로 구성된다.

#### 1. 실행 컨텍스트 스택

- 코드의 실행 순서를 관리하는 자료구조로, LIFO구조이다.

<br>

#### 2. 렉시컬 환경

- 모든 식별자와 바인딩된 값, 스코프를 기록 및 관리하는 자료구조이다.
- 키와 값을 갖는 객체 형태의 스코프를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다.
- 즉, 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체다.

<br>

## 📌 19. SPA, CSR, SSR의 차이에 대해 설명해주세요.

SPA와 MPA의 근본적인 차이는 웹페이지의 구성방식에 대한 것입니다.

<br>

### SPA

SPA는 말 그대로 한 개의 페이지로 이루어진 애플리케이션이라는 의미입니다. 전통적인 웹 페이지는 여러 페이지로 구성되어 있습니다.

기존에는 사용자가 다른 페이지로 이동할 때마다 새로운 html을 받아 오고, 페이지를 로딩할때마다 서버에서 리소스를 전달받아 해석한 뒤 화면에 보여 주었습니다.

이렇게 사용자에게 보이는 화면을 서버 측에서 준비했는데 요즘의 웹은 제공되는 정보가 너무 많기 때문에 새로운 화면을 보여줘야 할 때마다 서버 측에서 모든 뷰를 제공한다면 성능상에서 문제가 발생할 수 있습니다.

예를 들어 트래픽이 너무 많이 나올 수도 있고, 사용자가 몰려 서버에 높은 부하가 쉽게 걸릴 수도 있습니다.

따라서 리액트 같은 라이브러리를 사용하여 뷰 렌더링을 사용자의 브라우저가 담당하도록 하고, 애플리케이션을 우선 브라우저에 불러와서 실행시킨 후에 사용자와의 인터렉션이 발생하면 필요한 부분만 자바스크립트를 사용하여 업데이트합니다.

만약 새로운 데이터가 필요하다면 서버 API를 호출하여 필요한 데이터만 새로 불러와 애플리케이션에서 사용할 수도 있습니다.

<br>

### MPA

MPA는 여러 개의 페이지로 구성된 애플리케이션입니다. 여러 개의 HTML을 보여주는 방식으로 화면마다 HTML이 존재합니다.

요청이 있을때마다 정적인 resource가 다운로도 되며, 페이지 구성에 필요한 모든 resource가 다운로드 되고 다시 렌더링됩니다.

MPA는 서버사이드렌더링 방식을 사용합니다.

<br>

## 둘의 차이

<br>

### SPA 장점

- 뛰어난 반응성을 가지고 있습니다.
- 프론트와 백엔드가 확실하게 분리되어 있습니다. 이는 개발의 복잡성을 줄여줍니다.
- 페이지 렌더링 시 깜빡거림이 없습니다.
- 필요한 부분만 업데이트하기 때문에 비교적 속도가 빠릅니다.

<br>

### SPA 단점

- MPA에 비해 상대적으로 SEO에 대한 노출이 어렵습니다.
  비동기로 렌더링되는 페이지로 인해 구글봇과 같은 크롤러가 웹페이지의 내용을 크롤링하기 어렵기 때문입니다.

- 자바스크립트를 사용하지 않으면 SPA를 구현할 수 없습니다.

- 앱의 규모가 커지면 자바스크립트 파일이 너무 커집니다.
  페이지 로딩 시 사용자가 실제로 방문하지 않을 수도 있는 페이지의 스크립트도 불러오기 때문입니다. 코드 스플리팅을 사용하면 로딩속도를 개선할 수 있습니다.

<br>

### MPA 장점

- SEO에 대해 관리가 용이합니다. 유저가 보는 방식과 웹 크롤러가 보는 방식이 동일합니다.

- 오랜 역사로 입문자에게 좋은 자료가 많습니다.

<br>

### MPA 단점

- 속도가 느립니다. 모든 페이지가 로드 될 때까지 기다려야하기 때문입니다.
- 프론트와 백엔드가 긴밀하게 연결되어있어 개발의 복잡성이 높습니다.
- 렌더링 시 깜빡거림이 존재합니다.

<br>

### SPA와 MPA을 어떨때 사용하는게 좋을까요?

- user의 interaction이 별로 없는 정적인 페이지 => MPA

- user의 interaction이 많고 다양한 정보들을 동적으로 제공하는 페이지 => SPA

<br>

### SSR과 CSR의 개념과 둘의 차이에 대해 설명해주세요

SSR과 CSR의 근본적인 차이는 렌더링 준비를 어디서 하느냐 입니다.

### SSR

렌더링이 서버측에서 이루어지는 방식을 말합니다.

1. 유저가 Website 요청을 보낸다.
2. 서버는 렌더링에 사용될 HTML 파일들을 생성하여 클라이언트로 전달한다.
3. 클라이언트는 받은 HTML 파일들을 우선 렌더링 하는데 보여지는 것만 가능하고 조작은 불가능하다.
4. 클라이언트는 JS파일을 다운로드한다.
5. 유저는 화면 내용을 볼 수 있고 유저의 조작들이 기록된다. (아직 실행X)
6. 클라이언트가 JS Framework를 실행시킨다.
7. 앞서 기록된 유저의 조작들이 실행되며, 이 시점부터 페이지의 정상적인 이용이 가능하다.

<br>

### CSR

렌더링이 클라이언트 측에서 이루어지는 방식을 말합니다.

1. 유저가 Website 요청을 보낸다.
2. CDN이 JS로 접근할 수 있는 HTML 파일들을 보낸다.
3. 클라이언트는 HTML과 JS를 다운로드한다.
4. JS가 실행되고, API를 호출하여 데이터를 요청한다.
5. 서버는 API로부터 요청에 데이터로 응답한다.
6. API로부터 도착한 데이터는 화면의 placeholder들을 채우고 이 시점부터 페이지의 정상적인 이용이 가능하다.

<br>

## 둘의 차이

### SSR 장점

- JS가 다운로드 되는 동안 사용자는 화면의 일정부분을 경험할 수 있다.
- 빠른 초기로딩
- 화면을 구성하는 각각의 페이지가 존재하기 때문에 SEO에 유리

<br>

### SSR 단점

- 빠른 초기 로딩으로 TTV(Time To View)와 TTI(Time TO Interact) 사이의 시간 간격이 생김
- 첫 페이지로딩은 빠르지만 이후 로딩들은 CSR보다 느린 속도를 가짐
- 추가 로딩시 화면 깜빡임 존재
- 화면 변경시 화면을 구성하는 모든 리소스들을 매번 다운로드 받아야함
- 매번 서버에 요청을 하기 때문에 서버의 많은 리소스들을 필요로 하여 서버에 부하를 준다.

<br>

### CSR 장점

- 첫 페이지 로딩은 느리지만 이후 로딩들은 SSR 보다 빠른 속도를 가짐.
- 추가 로딩시 화면 깜빡임 없음
- 화면 변경시 변경에 필요한 리소스들만 다운로드 받으면 됨.
- 서버에 부하가 적다.

<br>

### CSR 단점

- 한꺼번에 다운로드를 받기 때문에 그동안 사용자는 화면의 어떠한 부분도 경험할 수 없다.
- SSR과 비교하면 비교적 느린 초기 로딩
- SEO에 적합하지 않음. (JS까지 모두 다운 되어야 페이지가 로드되기 때문이다.)

<br>

## 어느 환경에서 사용하면 좋을까?

### SSR

- 한 번에 모든 파일을 다운로드 받을 필요가 없으므로 네트워크가 느린 곳
- 초기 로딩시에도 사용자의 경험을 우선시 할 때
- SEO를 신경 쓸 때
- 웹사이트에 동적인 컨텐츠가 많을 때

<br>

### CSR

- 한 번에 모든 파일을 다운로드 받으므로 네트워크가 빠른 곳
- 초기 로딩시 사용자의 경험을 비교적 덜 신경 쓸 때
- SEO를 신경쓰지 않을 때

<br>

## 📌 20. null, undefined, undeclared, NaN 에 대해 설명해주세요.

### null

- 빈 값
- null 이라는 빈 값을 의도적으로 할당했을 때, 생기는 타입

<br>

### undefined

- 아무런 값도 할당되지 않음
- 정의되지 않음
- var 선언문의 경우, 호이스팅 되었을 때, 변수 선언과 초기화가 동시에 일어나기 때문에, 변수가 undefined 됩니다.(타입 결정 안됨)

<br>

### undeclared

- 선언조차 되지 않음
- let, const 선언문의 경우, 호이스팅 되었을 때, 변수 선언과 초기화가 따로 이루어지기에, 변수가 undeclared되어 에러가 생깁니다.
- undeclared의 타입은 undefined

<br>

### NAN

- 컴퓨터로는 표현할 수 없는 숫자값
- 표현 불가능한 수치형 결과

<br>

```
console.log(undefined == null); //true
console.log(undefined === null); //false
```

  <br>

### 추가 인성 질문

- 요즘은 어떤 공부를 하고 계신가요?
- 완성도와 기간 내 마무리 중 어떤 걸 중요시 할지
- “팀에서 1인분을 한다”고 할 때, 1인분은 어떤걸 의미하는걸까요?
- 최신 기술 트렌드는 어떻게 추적하시나요?

  <br>

출처 : https://github.com/Esoolgnah/Frontend-Interview-Questions#star-%EC%A4%91%EC%9A%94%EB%8F%845
