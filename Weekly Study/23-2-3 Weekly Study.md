# 23년 2월 셋째주 Weekly Study

<br>

### 📜 목차

1. 커스텀 Hooks에 대해 설명해주세요
2. React에서 state의 불변성을 유지하라는 말이 있는데 이에 대해 설명해주세요.
3. 리액트 사용시에 부수효과로 인해 생기는 문제점이 있다면 어떤 것일까요?
4. 클래스 컴포넌트의 라이프 사이클에 대해 설명해주세요.
5. 함수 컴포넌트의 라이프 사이클에 대해 설명해주세요.
6. 언제 useState 대신 useRef를 쓸 수 있나요?
7. 리액트에서 setState는 비동기 동작인가요 동기 동작인가요?
8. useLayoutEffect는 무엇인가요?
9. SPA와 MPA의 개념과 둘의 차이에 대해 설명해주세요
10. SSR과 CSR의 개념과 둘의 차이에 대해 설명해주세요
11. 하이드레이션에 대해 설명해주세요.
12. React와 Next.js의 차이점에 대해 설명해주세요.
13. Next의 렌더링 수행 방식에 대해 설명해주세요
14. Suspense에 대해 설명해주세요.
15. LCP가 뭔가요?
16. FCP가 뭔가요?
17. 프로세스와 스레드 설명해주세요.
18. 싱글 스레드 개념과 장단점에 대해 설명해주세요.
19. 멀티 스레드 개념과 장단점에 대해 설명해주세요.
20. 쿠키 세션의 차이에 대해 설명해주세요.

<br>

## 📌 1. 커스텀 Hooks에 대해 설명해주세요

커스텀 훅은 기능이 정해진 것이 아닌 개발자가 자주 사용하는 로직을 함수로 구분하여 재사용성을 높여 사용하는 Hook 종류를 말합니다.

다른 Hook처럼 앞에 `use` 키워드를 붙여줘야하며, useState와 같은 내장 훅을 사용해서 생성하여도 됩니다.

커스텀 Hooks의 주된 목적은 재사용성을 높이며, 효율적인 관리를 하는 것입니다.

<br>

## 📌 2. React에서 state의 불변성을 유지하라는 말이 있는데 이에 대해 설명해주세요.

객체는 실제 데이터 값이 아닌 참조 값을 가집니다.

그렇게 때문에 복사하여 동일한 참조 값을 가지는 객체 중 하나라도 변경된다면, 모든 객체의 내부 값이 변경될 것입니다.

`...연산자`를 통해 복사할 경우 A와 B는 같은 값을 가지더라도 새로운 객체를 할당 받은 상태가 됩니다. 따라서 A와 B 내부의 값은 같아보이더라도 참조하는 객체가 다르기 때문에 무결성을 유지할 수 있습니다.

리액트에서는 데이터를 저장할 때 객체 형식 또는 배열 형식의 데이터를 많이 다루게 되는데, 원본 배열이 변경되는 경우 의도한 동작과 다르게 동작할 수 있으며, 어떤 함수에 의해 부수효과가 발생했는지 찾기 어려울 수 있습니다.

<br>

### 리액트가 렌더링되는 기본 4가지 상황은 언제일까요?

1. Props가 바뀔 때
2. state가 바뀔 때
3. 부모 컴포넌트가 리렌더링될 때
4. this.forceUpdate로 강제로 렌더링을 트리거할 때

<br>

## 📌 3. 리액트 사용시에 부수효과로 인해 생기는 문제점이 있다면 어떤 것일까요?

부수효과란 함수가 만들어진 목적과는 다른 효과 또는 부작용입니다.

쉽게 말하자면, 함수에 예상할 수 없는 일이 생길 가능성이 존재한다면, 이 함수는 부수 효과를 가질 수 있는 함수가 됩니다.

함수의 안팎에서 예기치 않은 일이 생길 가능성이 있는 함수는 순수함수가 될 수 없습니다. 비동기 요청을 보내는 함수는 요청이 실패할 가능성이 있습니다. 입력을 포함하는 함수도 입력에 따라 출력이 달라질 가능성이 있기 때문에 순수함수가 될 수 없죠

매개변수로 들어온 값을 직접 변경하는 함수 역시 순수함수가 될 수 없습니다.
배열과 같은 참조 자료형 객체를 어떤 함수 안에서 직접 변경한다면, 나중에 이 객체를 인자로 받는 다른 함수의 작업에 영향을 미칠 수 있기 때문입니다.

불순 함수라는 말이 부정적인 뉘앙스가 있지만, 비동기 http 요청처럼 부수효과가 필요한 경우들도 존재하기 때문에 나쁘다고 할 수 없습니다.

<br>

함수의 매개변수로 들어온 값을 직접 변경하는 것을 피하기만 해도, 부수 효과를 일으키지 않는 함수(순수 함수)를 만들 수 있습니다.

<br>

## 📌 4. 클래스 컴포넌트의 라이프 사이클에 대해 설명해주세요.

클래스 컴포넌트 라이프 사이클은 크게 3가지로 구분되어 사용됩니다.

1. 마운트

- constructor
- getDerivedStateFromProps(nextProps, prevState)
- render
- componentDidMount

<br>

2. 업데이트

<br>

3. 언마운트

<br>

### 마운트

1. constructor

- 생성자
- 컴포넌트가 생성되면 가장 먼저 실행되는 메서드
- 초기 state 값을 정할 수 있다.

2. getDerivedStateFromProps(nextProps, prevState)

- props로 받아 온 값을 state에 동기화시켜줄 때 사용한다.
- 최초 마운트, 업데이트 될때 render 메서드를 호출하기 직전에 호출된다.

3. render

- JSX를 렌더링
- 클래스형 컴포넌트를 렌더링 할 때 필수적인 메서드이다
- 데이터를 가공해서 보여준다.

4. componentDidMount

- 이 메서드가 호출된 시점에선 UI가 화면에 나타난 상태이다.
- 컴포넌트의 첫 번째 렌더링이 끝나게 되면 호출되는 메서드이다.

<br>

### 업데이트

- Props가 바뀔 때
- state가 바뀔 때
- 부모 컴포넌트가 리렌더링될 때
- this.forceUpdate로 강제로 렌더링을 트리거할 때

위 경우에 해당하면 라이프사이클의 업데이트 메서드들이 호출된다.

1. getDerivedStateFromProps(nextProps, prevState)

- 마운트 때와 동일하다.
- props나 state값이 갱신되면 이 메서드가 불린다.

2. shouldComponentUpdate

- 컴포넌트가 리렌더링을 해야할지 말아야할지를 결정하는 메서드이다.
- 반드시 true | false 만을 반환해야 한다.

3. render

- 마운트 때와 같다.
- 이때의 렌더링은 리렌더링이다.

4. getSnapshotBeforeUpdate

- 컴포넌트에 변화가 일어나기 직전의 DOM 상태를 가져온다.
- 특정 값을 반환하게 되면 componentDidUpdate 메서드의 3번 째 파라미터 값으로 전달된다.

5. componentDidUpdate

- 리렌더링이 완료된 이후 호출
- 이 시점의 화면은 변화가 모두 반영되어 나타가게 된다.
- getSnapshotBeforeUpdate 메서드와도 연관되어 세번째 파라미터로 반환된 값을 전달 받을 수 있습니다.

<br>

### 언마운트

1. componentWillUnmount

- 컴포넌트가 Web broswer에서 사라지기 전에 호출 된다.
- 컴포넌트에 할당해 두었던 setInterval이나 다른 이벤트들을 이 단계에서 제거해야 한다.

<br>

## 📌 5. 함수 컴포넌트의 라이프 사이클에 대해 설명해주세요.

함수 컴포넌트 내부가 실행되는 것은 constructor와 같다.

return은 render의 역할과 같다.

클래스형 컴포넌트에서 있었던 componentDidMount, componentDidUpdate, componentWillUnmount의 역할을 useEffect가 실행한다.

함수 컴포넌트의 라이프 사이클을 나타내보자면,

1. 함수 컴포넌트 호출
2. 함수 컴포넌트의 내부 실행
3. return 실행, 자식 컴포넌트 실행 및 화면 렌더링
4. useEffect 실행 (마운트, 업데이트, 언마운트)

함수 컴포넌트의 라이프 사이클이 클래스형 컴포넌트의 라이프 사이클보다 간결해진데는 React Hooks의 영향이 컸다.

<br>

## 📌 6. 언제 useState 대신 useRef를 쓸 수 있나요?

useRef는 구성요소가 변경될 때 재렌더를 트리거하지 않아야 하는 값을 저장해야 할 때 사용합니다.

예를 들어 DOM 노드에 대한 참조 또는 자주 업데이트되지만, 구성 요소의 모양에는 영향을 미치지 않는 값을 저장하는 것이 포함됩니다.

반면, useState는 구성 요소가 변경될 때 다시 렌더링을 트리거해야 하는 값을 저장해야 할 때 사용해야 합니다.

화면에 일부 내용을 표시하는 데 사용되는 값이나 양식 입력의 현재 값을 저장하는 것이 예입니다.

따라서 화면의 일부 내용을 표시하지 않는 경우, 렌더링에 영향을 받지 않아도 되는 경우에 useRef를 사용한다면 리렌더링을 조금 더 효율적으로 핸들링할 수 있습니다.

<br>

## 📌 7. 리액트에서 setState는 비동기 동작인가요 동기 동작인가요?

state 값을 갱신하는 함수인 setState는 비동기로 동작하는 훅 함수입니다.

react는 state, props 값에 따라 리렌더링이 발생하는데 한 컴포넌트 내에서 연속으로 바꿔주는 일이 생긴다면 비효율적으로 리렌더링이 여러번 발생하여 성능의 저하를 유발합니다. 따라서 리액트는 setState를 비동기 함수로 처리하여 컴포넌트 내의 비동기 함수를 처리하는 콜백큐가 다 비워지면 리렌더링하도록 설계했습니다.

### setState를 비동기 동작으로 취했을 때 얻을 이점이 무엇인가요?

setState가 비동기 동작을 취함으로써 자바스크립트 내의 실행 컨텍스트 스택이 돌아갈 때 동기적으로 실행되는 함수들을 모두 동작한 뒤에 큐에 존재하는 비동기적인 함수들을 이벤트 루프에 의해 꺼내와서 실행시킵니다.

setState가 동기적으로 실행된다면, 한 컴포넌트 내부에 존재하는 함수에 의해 state 값이 연속적으로 변경될 경우 리액트의 컴포넌트 리렌더링 조건에 의해 지속적으로 리렌더링이 될 것입니다.

<br>

## 📌 8. useLayoutEffect는 무엇인가요?

브라우저가 렌더링 될 때, js 파일은 브라우저에서 자바스크립트 엔진으로 권한을 넘겨 js 해당 파일을 파싱하고 그리게 됩니다.

브라우저가 스크린에 페인팅 작업이 완료된 이후에 useEffect를 실행하는 구조를 가졌습니다.

다라서 렌더링 할 때 useStete와 같이 초기 useState 값과 useEffect를 통해 채워지는 값이 다르다면, 화면이 렌더링 될 때 값이 순간적으로 변하는 것을 확인할 수 있습니다.

이런 문제점을 해결하기 위해 나온 훅이 바로 useLayoutEffect입니다.

useLayoutEffect는 브라우저가 화면에 DOM을 그리기 전에 이펙트를 수행합니다.

따라서 코드의 실행 순서도 변경되어 useLayoutEffect내의 코드를 먼저 호출 한 뒤에 페인트 과정을 진행합니다.

## 📌 9. SPA와 MPA의 개념과 둘의 차이에 대해 설명해주세요

SPA와 MPA의 근본적인 차이는 웹페이지의 구성방식에 대한 것입니다.

<br>

### SPA

SPA는 말 그대로 한 개의 페이지로 이루어진 애플리케이션이라는 의미입니다. 전통적인 웹 페이지는 여러 페이지로 구성되어 있습니다.

기존에는 사용자가 다른 페이지로 이동할 때마다 새로운 html을 받아 오고, 페이지를 로딩할때마다 서버에서 리소스를 전달받아 해석한 뒤 화면에 보여 주었습니다.

이렇게 사용자에게 보이는 화면을 서버 측에서 준비했는데 요즘의 웹은 제공되는 정보가 너무 많기 때문에 새로운 화면을 보여줘야 할 때마다 서버 측에서 모든 뷰를 제공한다면 성능상에서 문제가 발생할 수 있습니다.

예를 들어 트래픽이 너무 많이 나올 수도 있고, 사용자가 몰려 서버에 높은 부하가 쉽게 걸릴 수도 있습니다.

따라서 리액트 같은 라이브러리 혹은 프레임워크를 사용하여 뷰 렌더링을 사용자의 브라우저가 담당하도록 하고, 우선 애플리케이션을 브라우저에 불러와서 실행시킨 후에 사용자와의 인터렉션이 발생하면 필요한 부분만 자바스크립트를 사용하여 업데이트합니다.

만약 새로운 데이터가 필요하다면 서버 API를 호출하여 필요한 데이터만 새로 불러와 애플리케이션에서 사용할 수도 있습니다.

<br>

### MPA

MPA는 여러 개의 페이지로 구성된 애플리케이션입니다. 여러 개의 HTML을 보여주는 방식으로 화면마다 HTML이 존재합니다.

요청이 있을때마다 정적인 resource가 다운로도 되며, 페이지 구성에 필요한 모든 resource가 다운로드 되고 다시 렌더링됩니다.

MPA는 서버사이드렌더링 방식을 사용합니다.

<br>

## 둘의 차이

<br>

### SPA 장점

- 뛰어난 반응성을 가지고 있습니다.
- 프론트와 백엔드가 확실하게 분리되어 있습니다. 이는 개발의 복잡성을 줄여줍니다.
- 페이지 렌더링 시 깜빡거림이 없습니다.
- 필요한 부분만 업데이트하기 때문에 비교적 속도가 빠릅니다.

<br>

### SPA 단점

- MPA에 비해 상대적으로 SEO에 대한 노출이 어렵습니다.
  비동기로 렌더링되는 페이지로 인해 구글봇과 같은 크롤러가 웹페이지의 내용을 크롤링하기 어렵기 때문입니다.

- 자바스크립트를 사용하지 않으면 SPA를 구현할 수 없습니다.

- 앱의 규모가 커지면 자바스크립트 파일이 너무 커집니다.
  페이지 로딩 시 사용자가 실제로 방문하지 않을 수도 있는 페이지의 스크립트도 불러오기 때문입니다. 코드 스플리팅을 사용하면 로딩속도를 개선할 수 있습니다.

<br>

### MPA 장점

- SEO에 대해 관리가 용이합니다. 유저가 보는 방식과 웹 크롤러가 보는 방식이 동일합니다.

- 오랜 역사로 입문자에게 좋은 자료가 많습니다.

<br>

### MPA 단점

- 속도가 느립니다. 모든 페이지가 로드 될 때까지 기다려야하기 때문입니다.
- 프론트와 백엔드가 긴밀하게 연결되어있어 개발의 복잡성이 높습니다.
- 렌더링 시 깜빡거림이 존재합니다.

<br>

### SPA와 MPA을 어떨때 사용하는게 좋을까요?

- user의 interaction이 별로 없는 정적인 페이지 => MPA

- user의 interaction이 많고 다양한 정보들을 동적으로 제공하는 페이지 => SPA

<br>

## 📌 10. SSR과 CSR의 개념과 둘의 차이에 대해 설명해주세요

SSR과 CSR의 근본적인 차이는 렌더링 준비를 어디서 하느냐 입니다.

### SSR

렌더링이 서버측에서 이루어지는 방식을 말합니다.

1. 유저가 Website 요청을 보낸다.
2. 서버는 렌더링에 사용될 HTML 파일들을 생성하여 클라이언트로 전달한다.
3. 클라이언트는 받은 HTML 파일들을 우선 렌더링 하는데 보여지는 것만 가능하고 조작은 불가능하다.
4. 클라이언트는 JS파일을 다운로드한다.
5. 유저는 화면 내용을 볼 수 있고 유저의 조작들이 기록된다. (아직 실행X)
6. 클라이언트가 JS Framework를 실행시킨다.
7. 앞서 기록된 유저의 조작들이 실행되며, 이 시점부터 페이지의 정상적인 이용이 가능하다.

<br>

### CSR

렌더링이 클라이언트 측에서 이루어지는 방식을 말합니다.

1. 유저가 Website 요청을 보낸다.
2. CDN이 JS로 접근할 수 있는 HTML 파일들을 보낸다.
3. 클라이언트는 HTML과 JS를 다운로드한다.
4. JS가 실행되고, API를 호출하여 데이터를 요청한다.
5. 서버는 API로부터 요청에 데이터로 응답한다.
6. API로부터 도착한 데이터는 화면의 placeholder들을 채우고 이 시점부터 페이지의 정상적인 이용이 가능하다.

<br>

## 둘의 차이

### SSR 장점

- JS가 다운로드 되는 동안 사용자는 화면의 일정부분을 경험할 수 있다.
- 빠른 초기로딩
- 화면을 구성하는 각각의 페이지가 존재하기 때문에 SEO에 유리

<br>

### SSR 단점

- 빠른 초기 로딩으로 TTV(Time To View)와 TTI(Time TO Interact) 사이의 시간 간격이 생김
- 첫 페이지로딩은 빠르지만 이후 로딩들은 CSR보다 느린 속도를 가짐
- 추가 로딩시 화면 깜빡임 존재
- 화면 변경시 화면을 구성하는 모든 리소스들을 매번 다운로드 받아야함
- 매번 서버에 요청을 하기 때문에 서버의 많은 리소스들을 필요로 하여 서버에 부하를 준다.

<br>

### CSR 장점

- 첫 페이지 로딩은 느리지만 이후 로딩들은 SSR 보다 빠른 속도를 가짐.
- 추가 로딩시 화면 깜빡임 없음
- 화면 변경시 변경에 필요한 리소스들만 다운로드 받으면 됨.
- 서버에 부하가 적다.

<br>

### CSR 단점

- 한꺼번에 다운로드를 받기 때문에 그동안 사용자는 화면의 어떠한 부분도 경험할 수 없다.
- SSR과 비교하면 비교적 느린 초기 로딩
- SEO에 적합하지 않음. (JS까지 모두 다운 되어야 페이지가 로드되기 때문이다.)

<br>

## 어느 것을 어떨 때 사용하면 좋을까?

### SSR

- 한 번에 모든 파일을 다운로드 받을 필요가 없으므로 네트워크가 느린 곳
- 초기 로딩시에도 사용자의 경험을 우선시 할 때
- SEO를 신경 쓸 때
- 웹사이트에 동적인 컨텐츠가 많을 때

<br>

### CSR

- 한 번에 모든 파일을 다운로드 받으므로 네트워크가 빠른 곳
- 초기 로딩시 사용자의 경험을 비교적 덜 신경 쓸 때
- SEO를 신경쓰지 않을 때
