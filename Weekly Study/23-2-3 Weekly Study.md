# 23년 2월 셋째주 Weekly Study

<br>

### 📜 목차

1. 커스텀 Hooks에 대해 설명해주세요
2. React에서 state의 불변성을 유지하라는 말이 있는데 이에 대해 설명해주세요.
3. 리액트 사용시에 부수효과로 인해 생기는 문제점이 있다면 어떤 것일까요?
4. 클래스 컴포넌트의 라이프 사이클에 대해 설명해주세요.
5. 함수 컴포넌트의 라이프 사이클에 대해 설명해주세요.
6. 언제 useState 대신 useRef를 쓸 수 있나요?
7. 리액트에서 setState는 비동기 동작인가요 동기 동작인가요?
8. useLayoutEffect는 무엇인가요?
9. SPA와 MPA의 개념과 둘의 차이에 대해 설명해주세요
10. SSR과 CSR의 개념과 둘의 차이에 대해 설명해주세요
11. 하이드레이션에 대해 설명해주세요.
12. React와 Next.js의 차이점에 대해 설명해주세요.
13. Next의 렌더링 수행 방식에 대해 설명해주세요
14. Suspense에 대해 설명해주세요.
15. LCP가 뭔가요?
16. FCP가 뭔가요?
17. 프로세스와 스레드 설명해주세요.
18. 싱글 스레드 개념과 장단점에 대해 설명해주세요.
19. 멀티 스레드 개념과 장단점에 대해 설명해주세요.
20. 쿠키 세션의 차이에 대해 설명해주세요.

<br>

## 1. 커스텀 Hooks에 대해 설명해주세요

커스텀 훅은 기능이 정해진 것이 아닌 개발자가 자주 사용하는 로직을 함수로 구분하여 재사용성을 높여 사용하는 Hook 종류를 말합니다.

다른 Hook처럼 앞에 `use` 키워드를 붙여줘야하며, useState와 같은 내장 훅을 사용해서 생성하여도 됩니다.

커스텀 Hooks의 주된 목적은 재사용성을 높이며, 효율적인 관리를 하는 것입니다.

<br>

## 2. React에서 state의 불변성을 유지하라는 말이 있는데 이에 대해 설명해주세요.

객체는 실제 데이터 값이 아닌 참조 값을 가집니다.

그렇게 때문에 복사하여 동일한 참조 값을 가지는 객체 중 하나라도 변경된다면, 모든 객체의 내부 값이 변경될 것입니다.

`...연산자`를 통해 복사할 경우 A와 B는 같은 값을 가지더라도 새로운 객체를 할당 받은 상태가 됩니다. 따라서 A와 B 내부의 값은 같아보이더라도 참조하는 객체가 다르기 때문에 무결성을 유지할 수 있습니다.

리액트에서는 데이터를 저장할 때 객체 형식 또는 배열 형식의 데이터를 많이 다루게 되는데, 원본 배열이 변경되는 경우 의도한 동작과 다르게 동작할 수 있으며, 어떤 함수에 의해 부수효과가 발생했는지 찾기 어려울 수 있습니다.

<br>

### 리액트가 렌더링되는 기본 4가지 상황은 언제일까요?

1. Props가 바뀔 때
2. state가 바뀔 때
3. 부모 컴포넌트가 리렌더링될 때
4. this.forceUpdate로 강제로 렌더링을 트리거할 때

<br>

## 3. 리액트 사용시에 부수효과로 인해 생기는 문제점이 있다면 어떤 것일까요?

부수효과란 함수가 만들어진 목적과는 다른 효과 또는 부작용입니다.

쉽게 말하자면, 함수에 예상할 수 없는 일이 생길 가능성이 존재한다면, 이 함수는 부수 효과를 가질 수 있는 함수가 됩니다.

함수의 안팎에서 예기치 않은 일이 생길 가능성이 있는 함수는 순수함수가 될 수 없습니다. 비동기 요청을 보내는 함수는 요청이 실패할 가능성이 있습니다. 입력을 포함하는 함수도 입력에 따라 출력이 달라질 가능성이 있기 때문에 순수함수가 될 수 없죠

매개변수로 들어온 값을 직접 변경하는 함수 역시 순수함수가 될 수 없습니다.
배열과 같은 참조 자료형 객체를 어떤 함수 안에서 직접 변경한다면, 나중에 이 객체를 인자로 받는 다른 함수의 작업에 영향을 미칠 수 있기 때문입니다.

불순 함수라는 말이 부정적인 뉘앙스가 있지만, 비동기 http 요청처럼 부수효과가 필요한 경우들도 존재하기 때문에 나쁘다고 할 수 없습니다.

<br>

함수의 매개변수로 들어온 값을 직접 변경하는 것을 피하기만 해도, 부수 효과를 일으키지 않는 함수(순수 함수)를 만들 수 있습니다.

<br>

## 4. 클래스 컴포넌트의 라이프 사이클에 대해 설명해주세요.

클래스 컴포넌트 라이프 사이클은 크게 3가지로 구분되어 사용됩니다.

1. 마운트

- constructor
- getDerivedStateFromProps(nextProps, prevState)
- render
- componentDidMount

<br>

2. 업데이트

<br>

3. 언마운트

<br>

### 마운트

1. constructor

- 생성자
- 컴포넌트가 생성되면 가장 먼저 실행되는 메서드
- 초기 state 값을 정할 수 있다.

2. getDerivedStateFromProps(nextProps, prevState)

- props로 받아 온 값을 state에 동기화시켜줄 때 사용한다.
- 최초 마운트, 업데이트 될때 render 메서드를 호출하기 직전에 호출된다.

3. render

- JSX를 렌더링
- 클래스형 컴포넌트를 렌더링 할 때 필수적인 메서드이다
- 데이터를 가공해서 보여준다.

4. componentDidMount

- 이 메서드가 호출된 시점에선 UI가 화면에 나타난 상태이다.
- 컴포넌트의 첫 번째 렌더링이 끝나게 되면 호출되는 메서드이다.

<br>

### 업데이트

- Props가 바뀔 때
- state가 바뀔 때
- 부모 컴포넌트가 리렌더링될 때
- this.forceUpdate로 강제로 렌더링을 트리거할 때

위 경우에 해당하면 라이프사이클의 업데이트 메서드들이 호출된다.

1. getDerivedStateFromProps(nextProps, prevState)

- 마운트 때와 동일하다.
- props나 state값이 갱신되면 이 메서드가 불린다.

2. shouldComponentUpdate

- 컴포넌트가 리렌더링을 해야할지 말아야할지를 결정하는 메서드이다.
- 반드시 true | false 만을 반환해야 한다.

3. render

- 마운트 때와 같다.
- 이때의 렌더링은 리렌더링이다.

4. getSnapshotBeforeUpdate

- 컴포넌트에 변화가 일어나기 직전의 DOM 상태를 가져온다.
- 특정 값을 반환하게 되면 componentDidUpdate 메서드의 3번 째 파라미터 값으로 전달된다.

5. componentDidUpdate

- 리렌더링이 완료된 이후 호출
- 이 시점의 화면은 변화가 모두 반영되어 나타가게 된다.
- getSnapshotBeforeUpdate 메서드와도 연관되어 세번째 파라미터로 반환된 값을 전달 받을 수 있습니다.

<br>

### 언마운트

1. componentWillUnmount

- 컴포넌트가 Web broswer에서 사라지기 전에 호출 된다.
- 컴포넌트에 할당해 두었던 setInterval이나 다른 이벤트들을 이 단계에서 제거해야 한다.

<br>

## 5. 함수 컴포넌트의 라이프 사이클에 대해 설명해주세요.

함수 컴포넌트 내부가 실행되는 것은 constructor와 같다.

return은 render의 역할과 같다.

클래스형 컴포넌트에서 있었던 componentDidMount, componentDidUpdate, componentWillUnmount의 역할을 useEffect가 실행한다.

함수 컴포넌트의 라이프 사이클을 나타내보자면,

1. 함수 컴포넌트 호출
2. 함수 컴포넌트의 내부 실행
3. return 실행, 자식 컴포넌트 실행 및 화면 렌더링
4. useEffect 실행 (마운트, 업데이트, 언마운트)

함수 컴포넌트의 라이프 사이클이 클래스형 컴포넌트의 라이프 사이클보다 간결해진데는 React Hooks의 영향이 컸다.

<br>
