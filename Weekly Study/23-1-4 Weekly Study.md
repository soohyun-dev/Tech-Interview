# 23년 1월 넷째주 Weekly Study

<br>

### 📜 목차

1. 컴파일러는 뭐고 인터프리터는 뭔가요?
2. 식별자란 무엇인가요?
3. 호이스팅이 뭔가요?
4. var,let,const 의 차이점 및 개념을 설명하시오.
5. 데이터 타입의 종류는?
6. 데이터 타입이 왜 필요할까요?
7. forEach, map, filter ,reduce 간단히 설명하시오.
8. 값에 의한 전달, 참조에 의한 전달 차이점
9. 함수 선언문과 표현식의 차이점
10. 스코프의 개념 및 종류
11. 렉시컬 스코프의 개념 설명
12. 일급 객체가 뭔가요?
13. 함수형 프로그래밍이 뭔가요?
14. 순수 함수가 뭔가요? 일반 함수와는 어떤 차이가 있나요?
15. 객체지향 프로그래밍의 정의 및 특징
16. 프로토타입이 뭔가요?
17. strict mode를 쓰는 이유
18. this가 뭔가요?
19. this 바인딩이란?
20. 실행 컨텍스트에 대해 말해보세요.

<br>

## 📌 1. 컴파일러는 뭐고 인터프리터는 뭔가요?

- 코드를 통해 내린 명령을 수행할 주체는 컴퓨터이다. 따라서, 사람이 이해할 수 있는 자연어를 컴퓨터가 이해할 수 있는 기계어로 변환해 명령을 전달해야 한다. 이 일종의 번역기를 컴파일러 혹은 인터프리터라고 한다.

  `compile: 변환하다, inpterpret: 해석하다`

  <br>

#### 컴파일러 언어 : C, C++, C#, JAVA 등

컴파일러는 고급 언어를 저급언어로 바꾸는 프로그램을 말함.

고급언어가 C, JAVA와 같은 언어들이고, 저급언어는 어셈블리어 기계어 같은 언어들을 말함.

컴파일러 언어는 컴파일 단계와 실행 단계가 각각 분리되어 있어서 실행시에 컴파일 과정을 거치지 않으므로 코드 실행 속도가 빠름.

다만, 프로젝트의 규모가 클 경우 컴파일 시간이 오래걸릴 수 있음.

<br>

#### 인터프리터 언어: Python, JS, Ruby 등

컴파일하지 않고 소스코드를 한 줄 씩 읽어들여서 실행함.

컴파일 하는 과정이 없기 때문에 컴파일 하는 시간은 따로 소요되지 않지만, 실행시마다 인터프리트 과정이 반복 수행되어서 실행 시간이 느림

<br>

```
컴파일러 언어는 번역책을 만들어서 주는 것이고,
인터프리터 언어는 한줄한줄 번역해준다고 생각하면 됨.

또한, 컴파일러 언어는 오류가 하나라도 있을 시 전체가 실행되지 않지만,
인터프리터 언어는 오류가 생기는 코드 전까지는 코드 실행을 할 수 있다.
```

<br>

## 📌 2. 식별자란 무엇인가요?

식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. 식별자는 값이 아니라 메모리 주소를 기억한다.

변수 뿐만 아니라 함수, 클래스 등의 이름은 모두 식별자임.
즉, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 모든 이름을 식별자라고 부름.

<br>

## 📌 3. 호이스팅이 뭔가요?

JS엔진은 모든 선언문을 소스코드의 위치에 상관 없이 다른 코드들보다 먼저 실행함. 런타임 이전에 실행 컨텍스트에 의해 소스코드 평가 과정에서 스코프에 등록되어 마치 코드의 제일 상단으로 끌어올려진 것과 같은 효과를 불러와 변수가 어디에 선언 되었든 변수를 참조할 수 있게 만드는 특징을 호이스팅이라고 한다.

var, let, const 뿐만 아니라 function, class 키워드를 사용하여 선언하는 모든 식별자들은 호이스팅 된다.

모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.

<br>

## 📌 4. var,let,const 의 차이점 및 개념을 설명하시오.

우선 var의 문제점을 알아야한다.

1. var는 함수레벨 스코프만을 지역스코프로 인정한다. 이는 블록 단위 내에 선언된 변수는 지역스코프로 인정하지 않기 때문에 원치 않은 값 변경을 유발할 수 있게한다.

2. var는 선언과 초기화 단계가 이루어져 동시에 undefined로 초기화된다.
   이는 값을 할당하지도 않았는데, 선언만으로 undefined라는 값이 할당되어 선언 전에 호출이 가능해져버린다.

3. 변수 중복 선언이 가능하다.

이러한 단점들을 보완하기 위해 나온 것이 let 과 const 이다.

<br>

### let

1. 변수 중복 선언은 불가능하지만, 재할당은 가능하다.

2. 블록 레벨 스코프를 따른다.

3. 선언과 초기화단계가 구분되어 이루어진다.

스코프 시작 지점 부터 초기화 단계까지 let으로 선언한 변수를 참조할 수 없다. 이 구간을 `일시적 사각지대 TDZ`라고 부른다.

```javascript
console.log(a); // 초기화 에러, TDZ
let a;
```

4. let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니어서 `window.a`와 같이 접근 할 수 없다.

<br>

### const

1. 선언과 초기화가 동시에 이루어져야한다.

```javascript
const a; // 에러
const b=1;
```

2. 변수 중복 선언 뿐만 아니라, 재할당까지 금지된다. 따라서, 상수를 표현하는데 사용하기 적합하다.

<br>

요약

- var : 선언 및 초기화 | 할당
- let : 선언 | ~ (TDZ) ~ 초기화 | 할당
- const : 선언 + 초기화 + 할당

<br>

## 📌 5. 데이터 타입의 종류는?

#### 원시 타입

- 원시 타입은 값 자체가 메모리 셀에 들어가 있다.
- 원시 타입은 값이 복사되어 전달된다. (pass by value)

1. number
2. string
3. boolean
4. undefined
5. null
6. symbol
7. BigInt

<br>

#### 객체 타입

- 객체 타입은 참조값 즉, 메모리 주소가 변수에 들어가 있다.
- 객체 타입은 참조값이 복사되어 전달된다. (pass by reference)

ex. 객체, 함수, 배열 등 원시 타입을 제외한 나머지 모든 값들.

<br>

## 📌 6. 데이터 타입이 왜 필요할까요?

1. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
2. 값을 참조할 대 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
3. 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

<br>

## 📌 7. forEach, map, filter ,reduce 간단히 설명하시오.

위 함수들을 고차함수라고 부르는데, 함수를 인자로 받거나 함수를 반환함으로써 작동하는 함수를 말한다.

1. 함수를 인자로 받아 실행하는 함수
2. 함수의 결과값으로 함수를 사용하는 함수 (클로저를 만들어 리턴하는 함수)

<br>

### forEach

for문과 유사하다. 각각의 배열요소들을 순회하는 역할을 한다.
반환하는 언제나 undefined이며, for문과의 차이점이라면 break와 같은 명령어로 순회를 도중에 중단하는 것이 불가능하다.

### map

forEach메서드가 단순히 반복문을 대체하기 위한 고차함수라면, map메서드는 요소값을 다른 값으로 매핑한 새로운 배열을 생성하기 위한 고차함수이다.
forEach문과 같이 break와 같은 명령어로 순회를 도중에 중단하는 것이 불가능하다.

### filter

주어진 조건에 맞는 요소들만으로 이루어진 새로운 배열을 반환한다.

### reduce

여러개의 값이 담긴 배열을 줄여서 최종적인 누적값만을 반환한다.
배열 요소의 모든 합과 같은 기능을 작성할때 유용하다.

첫번째 호출 일때 초기값이 존재하면 이 값이 초기값이며, 초기값을 제공하지 않으면 1번 인덱스부터 순회한다.

<br>

## 📌 8. 값에 의한 전달, 참조에 의한 전달 차이점

<br>

#### 값에 의한 전달

```javascript
let score = 50;
let copy = score;
score = 100;

console.log(score); // 100
console.log(copy); // 50
```

copy에 원시 값을 갖는 변수를 할당하면 copy에는 할당하는 변수의 원시 값이 복사되어 전달된다. 이때 score와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.

✔️ score 값을 변경해도 copy에는 영향이 없다.

<br>

#### 참조에 의한 전달

```javascript
let person = {
  name: "soohyun",
};
let copy = person;

copy.name = "soo";

console.log(person.name); // soo
console.log(copy.name); // soo
```

객체는 프로퍼티를 동적으로 추가하고 삭제할 수 있으며 프로퍼티의 값에 제약이 없다. 따라서 객체는 메모리 공간의 크기를 사전에 정의할 수 없으므로, 객체를 할당한 변수는 객체의 메모리 공간에 접근하여 참조해야한다.

이 객체를 할당한 변수 person을 copy 변수에 할당하게 되면 copy 변수도 똑같이 객체의 메모리 공간에 접근하여 참조하게 된다.

이는 객체를 가리키고 있는 변수 어느 하나를 재설정하게 되면 이 메모리 공간을 가리키고 있는 모든 변수에게 영향를 끼친다.

<br>

✔️ 코테에서 많이 사용하는 객체 복사

deepcopy로만은 원시값 변경이 이뤄짐.
이럴때는 JSON.stringfy, JSON.parse를 사용하면 참조 연결이 끊기기 때문에 유용함.

<br>

## 📌 9. 함수 선언문과 표현식의 차이점

```javascript
console.dir(add); // f add(x, y) , 호이스팅
console.dir(sub); // 초기화 전 참조에러
console.dir(multiply); // undefined

console.log(add(1, 4)); // 5
console.log(sub(1, 4)); // 초기화 전 참조에러
console.log(multiply(1, 4)); // TypeError

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
const sub = function (x, y) {
  return x - y;
};

var multiply = function (x, y) {
  return x * y;
};
```

함수 선언문은 런타임 이전에 js엔진에 의해 값을 할당하고 실행된다. 따라서 선언전에 함수를 참조할 수 있고 호출할 수도 있다. 함수 호이스팅이 발생한 것이다.

함수 표현식은 런타임에 값을 할당하기 때문에 선언 전에는 undefined가 할당되어 호출을 할 수 없다.

<br>

## 📌 10. 스코프의 개념 및 종류

스코프는 유효 범위라는 뜻으로 식별자가 유효한 범위를 말한다.
자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야할 것인지 결정한다.
따라서 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다.

#### 스코프 종류

- 전역 스코프
  전역에 변수를 선언하면 어디서든 참조할 수 있다.

- 지역 스코프
  지역 변수는 자신의 스코프와 하위 지역 스코프에서만 유효하다.

<br>

## 📌 11. 렉시컬 스코프의 개념 설명

함수를 어디서 '호출'했는지가 아닌 어디서 '정의'했는지에 따라 함수의 상위 스코프를 결정하는 것이 렉시컬 스코프를 의미한다.

```javascript
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

- bar 함수는 foo 함수와 마찬가지로 전역 스코프에 선언되어 있기 때문에 foo 함수 내부의 `var x = 10;`값을 참조할 수 없다.

<br>

## 📌 12. 일급 객체가 뭔가요?

일급이란?

- (1) 값으로 다룰 수 있다.
- (2) 변수에 담을 수 있다.
- (3) 함수의 인자로 사용될 수 있다.
- (4) 함수의 결과로 사용될 수 있다.

<br>

자바스크립트에서 함수는 일급이다.
즉, 함수를 값으로 다룰 수 있다. => 변수에 함수를 값으로 담아 다룰 수 있다.

<br>

## 📌 13. 함수형 프로그래밍이 뭔가요?

- 객체 지향 프로그래밍 : 데이터를 추상화 시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 프로그래밍 로직을 구성하는 프로그래밍 기법 (C++, C#, Java)

- 함수형 프로그래밍 : 순수 함수를 조합하여 소프트웨어를 만드는 방식

<br>

함수형 프로그래밍은 상태와 가변 데이터를 멀리하고 순수 함수를 이용하여 부수효과를 없애면서 프로그래밍의 안정성을 높이려는 프로그래밍 패러다임이다.

<br>

#### 함수형 프로그래밍의 특징

1. 어떻게? 과정 보다는 무엇을? 결과에 초점을 둔다.
2. 일급 객체
3. 고차함수
4. 불변성
5. 순수 함수
6. 루프보다는 재귀
7. Lazy 평가 (코드 실행 즉시 값을 평가하는 것이 아닌 필요한 시점에 값을 평가한다.)
8. 익명 함수

<br>

## 📌 14. 순수 함수가 뭔가요? 일반 함수와는 어떤 차이가 있나요?

#### 순수 함수

- 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수

#### 비순수 함수

- 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수효과가 있는 함수

<br>

## 📌 15. 객체지향 프로그래밍의 정의 및 특징

데이터를 추상화 시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 프로그래밍 로직을 구성하는 프로그래밍 기법 (C++, C#, Java)

<br>

특징

### 1. 추상화

- 객체를 구성할 수 있는 다양한 속성(프로퍼티)중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것을 추상화라고 한다.

### 2. 캡슐화

- 데이터 구조와 데이터를 다루는 방법들을 목적에 따라 결합시켜 묶는 것. 즉, 변수와 함수를 하나로 묶는 것을 말한다.
- 데이터를 절대로 외부에서 직접 접근하면 안되고 오로지 함수를 통해서만 접근하게 만든다.

### 3. 상속

- 상위 개념의 특징을 하위 개념이 물려받는 것

### 4. 다형성

- 부모클래스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩 되어 사용되는 것

<br>

## 📌 16. 프로토타입이 뭔가요?

프로토타입은 상속을 구현하기 위해 사용된다. 붕어빵을 만들기 위한 붕어빵 틀과 같은 존재다.

기본적으로 틀(프로토타입)에 우리가 원하는 앙금(인스턴스를 만들 때 생성자 함수에 들어갈 인수)을 넣어 기존에 만들어 놓은 프로퍼티에 바인딩하여 붕어빵(인스턴스)을 반환한다.
자바스크립트에서 기본 데이터 타입을 제외한 모든 것은 객체이다. 객체가 만들어지기 위해서는 자신을 만드는데 사용된 원형인 프로토타입 객체를 이용해서 객체를 만든다.

이때 만들어진 객체 안에 `_proto_` 속성이 자신을 만들어낸 원형을 의미하는 프로토타입 객체를 참조하는 숨겨진 링크가 있다.
이 숨겨진 링크를 프로토타입이라고 한다.

<br>

## 📌 17. strict mode를 쓰는 이유

오타나 문법 지식의 미비로 인한 실수를 줄여 안정적인 코드를 생산하기 위해 ES5에 추가된 모드이다.

JS의 문법을 좀 더 엄격하게 적용하여 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.

strict mode를 사용하면, 다음을 예방할 수 있다.

1. 암묵적 전역
2. 변수, 함수, 매개변수의 삭제
3. 매개변수 이름의 중복

<br>

## 📌 18. this가 뭔가요?

- this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다.
- this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스으 프로퍼티나 메서드를 참조할 수 있다.
- this는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있다.
- 단 this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.

<br>

## 📌 19. this 바인딩이란?

바인딩이란 식별자(변수)와 값(원시 값 또는 객체)을 연결하는 과정을 의미한다. <br>
예를 들어, 변수 선언은 변수 이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는 것이다. <br>
this 바인딩은 this(키워드로 분류되지만 식별자 역할을 한다)와 this가 가리킬 객체를 바인딩하는 것이다.

#### 함수 호출 방식에 따른 this 바인딩

일반 함수, 콜백 함수, 내부 함수는 전역객체
메서드 는 메서드를 호출한 객체
생성자 함수는 생성자 함수가 (미래에) 생성할 인스턴스
Function.prototype.apply/call/bind 메서드에 의한 간접 호출은 Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체이다.

<br>

## 📌 20. 실행 컨텍스트에 대해 말해보세요.

실행 컨텍스트는 소스 코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.
식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.

<br>

실행 컨텍스트는 1. 실행 컨텍스트 스택과 2. 렉시컬 환경으로 구성된다.

#### 1. 실행 컨텍스트 스택

- 코드의 실행 순서를 관리하는 자료구조로, LIFO구조이다.

<br>

#### 2. 렉시컬 환경

- 모든 식별자와 바인딩된 값, 스코프를 기록 및 관리하는 자료구조이다.
- 키와 값을 갖는 객체 형태의 스코프를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다.
- 즉, 렉시컬 환경은스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체다.
