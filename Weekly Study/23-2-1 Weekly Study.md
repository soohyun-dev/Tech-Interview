# 23년 2월 첫째주 Weekly Study

<br>

### 📜 목차

1. 콜백이란 뭐라고 생각하나요? 🔥
2. 프로미스가 뭔가요? 🔥
3. 프로미스의 상태를 나타내는 것은 어떤 것들이 있나요? 🔥
4. 프로미스 빌트인 객체가 제공하는 정적 메서드에 대해 알고 있나요? 🔥
5. 제너레이터란 뭔가요? 일반 함수와는 어떤 차이가 있죠?
6. async/await 가 뭔가요? 기존의 Promise와는 어떤 차이가 있죠? 🔥
7. Promise와 async/await의 차이점 한 줄 요약 🔥
8. 에러처리를 왜 해야 하나요?
9. 자바스크립트에서 에러를 처리하는 방법에는 뭐가 있을까요?
10. 모듈이 뭔가요?
11. meta 태그의 요소에 대해서 아는대로 말해보세요
12. Section 태그와 article 태그의 차이점
13. SEO란 무엇인가?
14. 크로스 브라우징이란 무엇인가요?
15. 이미지 크기가 클 경우 렌더링 속도가 느려질텐데 이를 개선하기 위한 방법
16. 시멘틱 태그란 무엇인가 왜 사용하는가
17. HTML5에서 추가된 내용이 있나요?
18. display 에 대해 설명해주세요
19. position 속성에 대해 설명해주세요
20. float에 대해 설명해주세요.

<br>

## 📌 1. 콜백이란 뭐라고 생각하나요? 🔥

자바스크립트에 콜백 함수는 다른 함수의 매개변수로 함수를 전달하고, 어떠한 이벤트가 발생한 후 매개변수로 전달한 함수가 다시 호출되는 것을 의미합니다.

어떤 일을 다른 객체에게 시키고, 그 일이 끝나는 것을 기다리지 않고 끝나고 부를 때까지 다른 일을 하는 것을 말합니다.

따라서, 동기 방식이 아닌 비동기 방식으로 처리하는 함수입니다.

<br>

## 📌 2. 프로미스가 뭔가요? 🔥

자바스크립트에서는 비동기 처리를 위한 패턴중 하나로 콜백 함수를 사용합니다

전통적인 콜백 패턴은 '콜백 헬'로 인해 가독성이 나쁘고 비동기 처리 중 발생한 에러의 처리가 곤란하며 여러 개의 비동기 처리를 한 번에 처리하는데 한계가 있습니다.

ES6에서 도입된 프로미스는, 이러한 콜백 함수의 문제점인 비동기 처리를 해결하기 위한 또 하나의 패턴입니다.

프로미스는 호스트 객체가 아닌 ECMAScript 사양에 정의된 표준 빌트인 객체입니다.

비동기 처리를 수행할 콜백 함수를 인수로 전달 받는데 이 콜백 함수는 resolve와 reject 함수를 인수로 전달받습니다.

Promise 생성자 함수가 인수로 전달받은 콜백 함수 내부에서 비동기 처리를 수행합니다. 이때 비동기 처리가 성공하면 resolve를, 실패하면 reject를 호출합니다.

<br>

## 📌 3. 프로미스의 상태를 나타내는 것은 어떤 것들이 있나요? 🔥

생성된 직후의 프로미스는 기본적으로 pending 상태입니다.

pending은 비동기 처리가 아직 수행되지 않은 상태를 의미한다.

fulfilled는 비동기 처리가 성공적으로 수행된 상태를 의미한다.

rejected는 비동기 처리가 수행되었지만 실패한 상태를 의미한다.

fulfilled 또는 rejected 인 상태를 settled 상태라고 한다. setteled 상태는 fulfilled 또는 rejected 상태와 상관없이 pending이 아닌 상태로 비동기 처리가 수행된 상태를 말한다.

setteled 상태가 되면 더 이상 다른 상태로 변화할 수 없다.

<br>

## 📌 4. 프로미스 빌트인 객체가 제공하는 정적 메서드에 대해 알고 있나요? 🔥

### Promise.resolve / Promise.reject

Promise.resolve / Promise.reject 정적 메서드는 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용합니다.

### Promise.all

Promise.all 메서드는 여러 개의 비동기 처리를 모두 병렬처리할 때 사용합니다.

Promise.all 메서드가 종료하는 데 걸리는 시간은 가장 늦게 fulfilled 상태가 되는 프로미스의 처리시간보다 조금 더 걸린다.

프로미스의 처리 시간에 의해 총 처리 시간이 결정되지만, 순서는 코드의 처리 순서를 보장한다.

즉, 코드를 작성한 순서대로 저장된다.

하나라도 에러가 발생할 시 fulfilled 상태가 되는 것을 기다리지 않고 즉시 종료한다.

```javascript
const requestData1 = () =>
  new Promise((resolve) => setTimeout(() => resolve(1), 3000));
const requestData2 = () =>
  new Promise((resolve) => setTimeout(() => resolve(2), 2000));
const requestData3 = () =>
  new Promise((resolve) => setTimeout(() => resolve(3), 1000));

Promise.all([requestData1(), requestData2(), requestData3()])
  .then(console.log) // [ 1, 2, 3 ] ⇒ 약 3초 소요
  .catch(console.error);
```

### Promise.race

Promise.all과 비슷하게 동작하지만, 다른 점은 모든 프로미스가 fulfilled 상태가 되는 것을 기다리는 것이 아닌 가장 먼저 fulfilled 상태가 된 프로미스의 처리 결과를 resolve하는 프로미스를 반환한다.

### Promise.allSettled

프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다.

전달 받은 프로미스가 모두 settled 상태가 되면 처리결과를 배열로 반환한다.

<br>

## 📌 5. 제너레이터란 뭔가요? 일반 함수와는 어떤 차이가 있죠?

ES6에서 도입된 제너레이터는 코드 블록의 실행을 일시 중지(블로킹) 했다가 필요한 시점에 재개할 수 있는 특수한 함수이다.

이러한 특성을 이용해서 함수형 프로그래밍에서 Lazy 기능을 구현할 수 있기도 하다.

1. 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.

이때 함수의 제어권을 함수가 독점 하는 것이 아니라 함수 호출자에게 양도할 수 있다는 것을 의미한다.

2. 제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다.

제너레이터 함수는 함수 호출자에게 상태를 전달할 수 있고 함수 호출자로부터 상태를 전달받을 수도 있다.

3. 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.

제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환한다.

제너레이터는 `yield`키워드와 `next`메서드를 통해 실행을 일시 중지했다가 필요한 시점에 다시 재개할 수 있다.

일반 함수는 호출 이후 제어권을 해당 함수가 독점하지만, 제너레이터는 함수 호출자에게 제어권을 양도(yield)하여 필요한 시점에 함수 실행을 재개할 수 있다.

netx 메서드를 통해 제너레이터를 실행할 경우, 코드 블록 내에 yield 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 리절트 객체 형식으로 반환한다.

```javscript
{ value : 1, done : false }
```

value가 뜻하는 것은 값, done은 순회가 종료되었는지를 나타낸다. done은 더이상 next를 진행할 수 없을 때 즉, next 메서드를 통해 순회를 마쳤을 때 true 값을 가진다.

<br>

## 📌 6. async/await 가 뭔가요? 기존의 Promise와는 어떤 차이가 있죠? 🔥

ES8에서는 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기 처리처럼 동작할도록 구현할 수 있는 async/await가 도입되었다.

async/await는 프로미스를 기반으로 동작하기 때문에 프로미스의 then/catch/finally 등의 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기 처리처럼 프로미스를 사용할 수 있다.

즉, 프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 다시 반환할 수 있도록 구현할 수 있다.

async await 으로 구현할 경우 제너레이터의 성질을 갖기 때문에 항상 프로미스가 setteled(이행된) 상태가 될 때까지 대기한다.

따라서, 모든 코드에 async await을 남발하는 것은 도움이 되지 않는다.

```javascript
async function foo() {
  const a = await new Promise((resolve) => setTimeout(() => resolve(1), 3000));
  const b = await new Promise((resolve) => setTimeout(() => resolve(2), 2000));
  const c = await new Promise((resolve) => setTimeout(() => resolve(3), 1000));

  console.log([a, b, c]); // [1, 2, 3]
}

foo(); // 약 6초 소요된다.
```

## 📌 7. Promise와 async/await의 차이점 한 줄 요약 🔥

1. 에러 핸들링

- Promise를 활용할 시에는 .catch() 문을 통해 에러 핸들링을 해야 하지만,
- async/await은 try/catch를 통해 에러를 처리할 수 있다.

<br>

2. 코드 가독성

- Promise의 후속 처리 메서드인 .then()의 hell의 가능성
- async/await은 프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있기 때문에 코드 흐름을 이해하기 쉽다.

<br>

## 📌 8. 에러처리를 왜 해야 하나요?

에러가 발생하지 않는 코드를 작성하는 것은 불가능합니다.

발생한 에러에 대해 대처하지 않고 방치한다면 프로그램은 강제 종료될 것입니다.

따라서 try catch 문을 사용해 발생한 에러를 적절하게 대응하면 프로그래밍이 강제 종료 되지 않고 계속해서 코드를 실행시킬 수 있습니다.

<br>

## 📌 9. 자바스크립트에서 에러를 처리하는 방법에는 뭐가 있을까요?

1. try catch finally

2. Error 객체

Error 생성자 함수는 에러 객체를 생성한다.

Error 생성자 함수에는 에러를 상세히 설명하는 에러 메시지를 인수로 전달할 수 있다.

자바스크립트는 Error 생성자 함수를 포함해 7가지의 Error 생성자 함수를 제공하며 해당 함수가 생성한 에러 객체의 프로토타입은 모두 Error.prototype을 상속받는다.

3. throw 문

Error 생성자 함수로 에러 객체를 생성한다고 에러가 발생하는 것은 아니다.

즉, 에러 객체 생성과 에러 발생은 의미가 다르다.

에러를 발생시키려면 try 코드 블록에서 throw문으로 에러 객체를 던져야한다.

<br>

## 📌 10. 모듈이 뭔가요?

모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말합니다.

일반적으로 모듈은 기능을 기준으로 파일 단위로 분리한다. 이때 모듈이 성립하려면 모듈은 자신만의 파일 스코프(모듈 스코프)를 가질 수 있어야 한다.

자신만의 파일 스코프를갖는 모듈의 자산(모듈에 포함되어 있는 변수, 함수, 객체 등)은 기본적으로 비공개 상태다. 즉, 모듈은 개별적 존재로서 애플리케이션과 분리되어 존재한다.

애플리케이션과 완전히 분리되어 개별적으로 존재하는 모듈은 재사용이 불가능하므로 존재의 의미가 없다.

따라서 모듈은 공개가 필요한 자산에 한정하여 명시적으로 선택적 공개가 가능하다.

이를 `export` 라 한다.

export한 자산은 다른 모듈에서 재사용할 수 있게 된다. (의존성을 갖게 된다.)

이때, 공개된 모듈의 자산을 사용하는 모듈을 모듈 사용자라 한다.

모듈 사용자는 모듈이 export한 자산 중 일부 또는 전체를 선택해 자신의 스코프 내로 불러들여 재사용할 수 있다.

이를 `import` 라 한다.

자바스크립트는 기본적으로 모듈이 성립하기 위해 필요한 파일 스코프와 import, export를 지원하지 않는다.

따라서 자바스크립트를 클라이언트 사이드, 즉 브라우저 환경에 국한하지 않고 범용적으로 사용하려는 움직임이 생기면서 이러한 상황에 제안된 것이 `CommonJS`와 `AMD(Asynchronous Module Definition)`이다.

<br>

## 📌 11. meta 태그의 요소에 대해서 아는대로 말해보세요

### charset

charset 요소는 문서에서 허용하는 문자 집합에 대해서 간단히 표시합니다.

name 요소는 메타 요소가 어떤 정보의 형태를 갖고 있는지 알려줍니다.

content 요소는 실제 메타 데이터의 컨텐츠입니다. 머릿말을 요약하는데 유용합니다.

<br>

## 📌 12. Section 태그와 article 태그의 차이점

<br>

### section 태그

- 논리적으로 관계가 있는 요소 또는 문서들을 분리할 때 사용
- 논리적으로 관계가 없다면 div를 쓴다.

### artcle 태그

- 글자가 많이 들어가는 부분에 사용된다.
- 독립적으로 존재할 수 있으며 재사용할 수 있다.

<br>

## 📌 13. SEO란 무엇인가?

검색 엔진 최적화(SEO: Search Engine Optimization)는 검색 엔진이 웹페이지의 자료를 수집하거나 순위를 방식에 맞게 웹페이지를 구성하여, 검색 결과를 상위에 나올 수 있게 하는 행위를 말합니다.

SEO를 위해서는 검색어를 페이지에 적절하게 배치해야 합니다.

검색 엔진은 결과를 보여줄 때, HTML의 태그들을 분석합니다.

이때, Semantic한 문서는 검색 엔진이 유의미한 결과를 낳을 수 있도록 합니다.

<br>

## 📌 14. 크로스 브라우징이란 무엇인가요?

크로스 브라우저는 웹 사이트 또는 웹 응용 프로그램이 서로 다른 웹 브라우저에서 정확하고 일관성 있게 작동하는 기능을 말합니다.

여기에는 구글 크롬, 파이어폭스, 사파리 등등 인기 있는 브라우저의 다영한 버전과 오페라오 같은 덜 사용되는 브라우저가 포함됩니다.

크로스 브라우징 호환성은 웹 사이트 또는 웹 응용 프로그램에 액세스하여 가능한 한 광범위한 사용자가 사용할 수 있도록 하는 것이 중요합니다.

<br>

## 📌 15. 이미지 크기가 클 경우 렌더링 속도가 느려질텐데 이를 개선하기 위한 방법

1. 이미지의 용량을 줄인다.
2. 이미지 스프라이트를 활용한다.
3. 벡터 이미지(SVG)를 활용한다.

<br>

#### 이미지 스프라이트 기법

- 여러 개의 이미지를 하나의 이미지로 만들어 놓는 것을 의미한다.

장점

1. 이미지 로딩 속도 향상(최적화)

2. HTML 마크업이 간결해지고 스크린 리더의 탐색 속도가 향상된다.

3. 하나의 파일만 관리하면 된다.

<br>

#### SVG란

픽셀을 이용하여 그림을 그리는 png, jpg 파일들과는 다르게 벡터를 기반으로 이미지를 표현한다.

크기를 조절함에 따라 깨지는 것이 없고, 용량이 작기 때문에 웹에서 자주 사용하는 이미지 형식이다.

<br>

## 📌 16. 시멘틱 태그란 무엇이고 왜 사용하나요?

시맨틱 태그는 HTML로 만든 문서에 추가적으로 의미를 부여해줍니다.

Non-Semantic Element로 문서를 작성할 경우 HTML문서를 접하는 사람이 어떤 데이터를 봐야할지, 어떤 데이터를 제공하는지 파악하기가 어렵습니다.

시맨틱 태그를 사용함으로써 서로 관계가 있는 정보를 파악하고 콘텐츠가 어떤 맥락 안에 있는지 알기 쉽게 해줍니다.

또한, 시맨틱 태그를 잘 지킨다면 이는 SEO를 통해 검색이 잘 될 수 있도록 도와줍니다.

- header
- nav
- aside
- section
- article
- footer

<br>

## 📌 17. HTML5에서 추가된 내용이 있나요?

- canvas 기능 추가
- 모든 디바이스에서 웹페이지 호환이 가능
- 시멘틱 웹 기술을 지원하기 시작

### canvas

- 자바스크립트를 통해 다양한 그림을 그릴 수 있는 공간을 제공

<br>

## 📌 18. display 에 대해 설명해주세요

<br>

### block

- 항상 새로운 라인에 요소가 시작되며 화면 크기의 가로 전체폭을 영역으로 차지한다.

<br>

### inlile

- 새로운 라인에서 시작되지 않으며, 다른 요소들과 같은 줄에 배치될 수 있고 content 너비만큼의 영역을 차지한다.

- width, height, margin-top, margin-bottom 속성이 적용되지 않는다.

<br>

### inline-block

- block 레벨 요소와 inline 레벨 요소의 특징을 모두 가지고 있다.

- 한 줄에서 inline 레벨 요소들과 같이 배치될 수 있으며, width,height 속성으로 영역의 크기를 지정할 수 있다.

<br>

### none

- 아예 사라지게 하는 것. 보이지도 않고 해당 공간도 존재하지 않는다.

<br>

## 📌 19. position 속성에 대해 설명해주세요

<br>

#### static

- 기본값으로 요소들이 겹치지 않고 상->하로 배치된다.

<br>

#### relative

- 원래 배치되어야 할 위치에서 지정된 값만큼 떨어진 곳에 요소를 배치한다.

<br>

#### fixed

- 웹 브라우저 화면 전체를 기준으로 배치한다. 스크롤을 하더라도 위치가 고정된다.

<br>

#### absolute

- 가장 가까운 상위 요소의 위치를 기준으로 지정한 값 만큼 떨어진 곳에 요소를 배치한다.

<br>

#### sticky

- 스크롤 위치가 임계점에 이르면 position: fixed와 같이 박스를 화면에 고정할 수 있는 속성으로 스크롤 영역 기준으로 배치한다.

<br>

## 📌 20. float에 대해 설명해주세요.

float는 css 위치지정 속성입니다.

float된 요소는 페이지의 흐름의 일부가 되며, 페이지의 흐름에서 제거되는 position: absolute 요소와 달리 다른 요소(예: 플로팅 요소 주위로 흐르는 텍스트)의 위치에 영향을 줍니다.

CSS clear 속성은 float 요소에 left/right/both에 위치하도록 사용될 수 있습니다.

부모 요소에 float 요소만 있으면, 그 높이는 무효가 됩니다.

컨테이너의 float 요소 다음에 있지만 컨테이너가 닫히기 전에 float를 clear하면 해결할 수 있습니다.
