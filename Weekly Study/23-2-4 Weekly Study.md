# 23년 2월 넷째주 Weekly Study

<br>

### 📜 목차

1. HTTP란 무엇인가요?
2. HTTP 프로토콜의 가장 큰 특징은 무엇인가요?
3. URL에 대해 설명해주세요
4. HTTP/1.1과 HTTP/2.0의 차이는 무엇인가요?
5. HTTPS는 HTTP랑 무엇이 다른가요?
6. CORS에 대해 설명해주세요.
7. SaaS에 대해 설명해주세요
8. 애자일 방법론에 대해 설명해주세요
9. 캐시에 대해 설명해주세요
10. CI CD에 대해 설명해주세요
11. CDN에 대해 설명해주세요
12. 유닛 테스트에 대해 설명해주세요
13. 통합 테스트에 대해 설명해주세요
14. E2E 테스트에 대해 설명해주세요
15. business logic에 대해 설명해주세요
16. snippet에 대해 설명해주세요
17. 웹팩의 개념과 등장한 이유, 사용 시 이점에 대해 설명해주세요
18. 모듈 번들링이란 무엇인가요?
19. 바벨에 대해 설명해주세요
20. 웹팩의 주요 속성 4가지가 무엇이라 생각하시나요?

<br>

## 📌 1. HTTP란 무엇인가요?

HTTP 란 HyperText Transfer Protocol의 약자로 데이터를 주고받기 위해 정의한 통신 프로토콜입니다.

웹을 기준으로 브라우저와 서버 간에 데이터를 주고 받기 윈한 방식으로 HTTP 프로토콜을 사용하고 있습니다.

<br>

## 📌 2. HTTP 프로토콜의 가장 큰 특징은 무엇인가요?

HTTP 프로토콜은 상태가 없는(stateless) 프로토콜입니다.

여기서 상태가 없다는 말은 데이터를 주고 받기 위한 각각의 데이터 요청이 서로 독립적으로 관리가 된다는 말입니다.

이전에 보냈던 데이터 요청과 다음에 보낼 데이터 요청이 서로 관련이 없다는 의미입니다.

이러한 특징 덕분에 서버는 세션과 같은 별도의 추가 정보를 관리하지 않아도 되고, 다수의 요청 처리 및 서버의 부하를 줄일 수 있는 성능 상의 이점이 생깁니다.

HTTP 프로토콜은 일반적으로 TCP/IP 통신 위에서 동작하며, 기본 포트는 80번 입니다.

<br>

## 📌 3. URL에 대해 설명해주세요

URL(Uniform Resource Locators)은 서버에 자원을 요청하기 위해 입력하는 영문 주소입니다.

숫자로 되어있는 IP주소보다는 훨씬 기억하기 쉽다는 장점이 있습니다.

브라우저에서는 이렇게 url로 되어있는 HTTP 요청을 DNS(Domain Name System)을 통해 host에 해당하는 실제 IP 주소로 변환하여 서버에 요청을 보냅니다.

<br>

### URI와 URL, URN의 차이

### URI

Scheme(protocol) + Host(domain) + Port + Path + Query + Fragement

### URL

Scheme(protocol) + Host(domain) + Port + Path

### URN

Host(domain) + Port + Path + Query + Fragement

<br>

## 📌 4. HTTP/1.1과 HTTP/2.0의 차이는 무엇인가요?

### HTTP/1.1

HTTP/1.1은 기본적으로 커넥션 당 하나의 요청과 응답만 처리한다.

즉, 여러 개의 요청을 한 번에 전송할 수 없고 응답 또한 마찬가지이다.

따라서 HTML 문서 내에 포함된 여러 개의 리소스 요청, 즉 CSS 파일을 로드하는 link 태그, 이미지 파일을 로드하는 img 태그, 자바스크립트를 로드하는 script 태그 등에 의한 리소스 요청이 개별적으로 전송되고 응답 또한 개별적으로 전송된다.

이처럼 HTTP/1.1은 리소스의 동시 전송이 불가능한 구조이므로 요청할 리소스의 개수에 비례하여 응답시간도 증가하는 단점이 있다.

<br>

### HTTP/2.0

HTTP/2는 커넥션당 여러 개의 요청과 응답, 즉 다중 요청/응답이 가능하다.

여러 리소스의 동시 전송이 가능하므로 HTTP/1.1에 비해 페이지 로드 속도가 약 50% 정도 빠르다고 알려져 있다.

<br>

## 📌 5. HTTPS는 HTTP랑 무엇이 다른가요

HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜입니다.

HTTPS는 HTTP(80번)와 다르게 443 포트를 사용하며, 네트워크 상에서 중간에 제 3자가 정보를 볼 수 없도록 공개키 암호화를 지원하고 있습니다.

HTTPS를 사용할 경우 내가 브라우저를 통해 입력하는 정보를 다른 누군가가 훔쳐보지 못하게 만드는 기능입니다.

HTTP 형식으로 입력한 정보를 보낼 경우, 입력한 형태 그대로 보내지게 됩니다.

ex) id: user_naver_id

따라서, 누군가가 악의적으로 이 요청을 캐치해서 내 정보를 들여다 본다면, 그대로 아이디와 비밀번호가 노출될 수 있습니다.

하지만, HTTPS를 사용할 경우, 이 통신 요청을 보낼 때 응답을 해주는 서버만 알아볼 수 있도록 정보를 암호화해서 보내게 됩니다.

ex) id: #$!@$!%!@(ad_s%1)

또한, HTTPS는 기관으로 검증된 사이트만 주소에 HTTPS 사용이 허가되기 때문에, 내가 접속한 사이트가 상대적으로 안전한 주소를 가졌음을 증명하는 것이기도 합니다.

<br>

## 📌 6. CORS에 대해 설명해주세요.

CORS는 Cross Origin Resource Sharing의 약자로 교차 출처 공유라는 의미 입니다.

Origin은 1. scheme 2. host 3. port 로 이루어진 도메인을 의미합니다.
(IE의 경우 port를 비교하지 않음)

```
https://www.naver.com/

① scheme : https
② host: www.naver.com
③ port: null (공개되지 않음)
```

현재 자신이 속한 출처(Origin)를 기준으로 다른 출처(Origin)에 API를 요청하게 되면 브라우저에서 이 요청으로 넘어오는 경과가 안전한지 판단하게 되는데,

응답을 보내는 출처가 자신이 속한 출처가 아닌, 2.다른 출처여도 서로 예상되는 출처라면 요청에 대해 허용해주는 응답 헤더를 보내, 브라우저가 응답 결과를 보여줍니다.

이를 CORS라고 합니다.

<br>

### 왜 브라우저가 CORS 요청을 처리하나요?

모든 서버들이 다 CORS를 인지하지는 않기 때문입니다.

결과적으로 브라우저는 거부했다고 하더라도, 서버는 처리해버리는 결과가 생길 수 있기 때문에 서버가 안전하게 요청을 주고받을 수 있도록 브라우저에서 해당 요청(CORS)을 처리한다.

<br>

### 실제 요청에서는 어떻게 처리하나요?

CORS는 다른 Origin에 대한 요청을 허용하는 정책입니다.

같은 Origin에서 http 통신을 하는 경우 알아서 cookie가 request header에 들어가지만, 교차 출처로 요청하는 상황에서는 그렇지 않습니다.

Origin이 다른 http 통신에서는 request header에 쿠키가 자동으로 들어가지 않기 때문에 서버에게 또는 클라이언트에게 내가 어떤 요청을 보내는지 알려줄 필요가 있습니다.

```
프론트 > WithCredentials: true

서버 > Access-Control-Allow-Credentials: true
```

<br>

### 해결해본 경험

- credentials 설정 체크
- 프록시 설정

<br>

## 📌 7. SaaS에 대해 설명해주세요

서비스로서의 소프트웨어(Software-as-a-Service)라는 뜻인 SaaS는 클라우드 애플리케이션과 기본 IT 인프라 및 플랫폼을 사용자에게 제공하는 클라우드 컴퓨팅 형태입니다.

SaaS는 클라우드 서비스 제공업체(AWS, Azure...)에 의해 클라우드 환경이 관리됩니다.

SW, 데이터를 PC에 별도 설치없이 웹에서 직접 사용할 수 있다는 장점이 있습니다.

SaaS의 예로는 Google Docs, Microsoft Office 365와 같은 소비자 대상 서비스와 인사 관리 소프트웨어, 콘텐츠 관리 시스템, 고객 관계 관리 툴, IDE를 제공하는 엔터프라이즈 서비스가 있습니다.

<br>

## 📌 8. 애자일 방법론에 대해 설명해주세요

애자일은 신속한 반복 작업을 통해 실제 작동 가능한 소프트웨어를 개발하여 지속적으로 제공하기 위한 소프트웨어 개발 방식입니다.

작동하는 소프트웨어의 작은 구성 요소를 신속하게 제공하여 고객의 만족도를 개선하는 것이 애자일 방법론의 핵심입니다.

다음과 같은 부분에 가치를 둡니다.

- 개인과 개인 간의 상호 작용이 프로세스 및 툴보다 우선
- 작동하는 소프트웨어가 포괄적인 문서보다 우선
- 고객과의 협업이 계약 협상보다 우선
- 변화에 대응하는 것이 계획을 따르는 것보다 우선

<br>

## 📌 9. 캐시에 대해 설명해주세요

### 기술적 Cache

자주 필요한 데이터나 값의 복사본을 일시적으로 저장, 보관하기 위해 사용하는 곳

캐싱: 캐시에 데이터나 계산된 결과 값의 복사본을 저장해 둠으로써 전체적인 처리 속도를 향상시킨다.

- 데이터에 직접적으로 접근하는 데 걸리는 시간이 오래 걸릴 때
- 필요한 값을 얻기 위해 계산하는 과정을 생략하고 싶을 떄
- 반복적으로 동일한 결과를 돌려주는 경우 (이미지나 썸네일 등)

캐싱은 복사본을 이용하는 것이다.

복사본과 원본이 달라지는 경우가 생길 수 있으니 일관성 유지에 유의하자.

<br>

## 📌 10. CI CD에 대해 설명해주세요

CI/CD는 애플리케이션 개발 단계를 자동화하여 애플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법입니다.

CI/CD의 기본 개념은 지속적인 통합, 지속적인 서비스 제공, 지속적인 배포입니다.

CI/CD는 새로운 코드 통합으로 인해 개발 및 운영팀에 발생하는 문제(일명 integration hell)을 해결하기 위한 솔루션입니다.

<br>

### CI

CI는 개발자를 위한 자동화 프로세스인 지속적인 통합 (Continuous Integration)을 의미합니다.

CI를 성공적으로 구현할 경우 애플리케이션에 대한 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어 공유 레포지토리에 통합되므로 여러 명의 개발자가 동시에 애플리케이션 개발과 관련된 코드 작업을 할 경우 서로 충돌할 수 있는 문제를 해결할 수 있습니다.

<br>

### CD

CD는 지속적인 제공 (Continuous Delivery) 및 지속적인 배포 (Continuous Deployment)를 의미합니다.

지속적인 제공이란 개발자들이 애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 레포지토리에 자동으로 업로드되는 것을 뜻합니다.

지속적인 배포란 개발자의 변경 사항을 레포지토리에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 릴리스 하는 것을 의미합니다.

<br>

## 📌 11. CDN에 대해 설명해주세요

CDN(콘텐츠 전송 네트워크)은 지리적으로 분산된 여러 개의 서버입니다.

웹 콘텐츠를 사용자와 가까운 곳에서 전송함으로써 전송 속도를 높입니다.

전 세계 데이터센터는 파일 복사본을 임시로 저장하는 프로세스인 캐싱을 사용합니다

따라서 사용자는 가까운 서버를 통해 웹 활성화 디바이스 또는 브라우저에서 인터넷 콘텐츠에 빠르게 접속할 수 있습니다.

CDN은 웹 페이지, 이미지, 비디오 등의 콘텐츠를 사용자의 물리적 위치와 가까운 프록시 서버에 캐싱합니다.

이렇게 하면 콘텐츠가 로딩될 때까지 기다릴 필요 없이 영화 감상, 소프트웨어 다운로드, 은행 잔고 확인, 소셜 미디어 포스팅, 구매 등의 작업을 할 수 있습니다.

인터넷으로 그래픽과 비디오 등 용량이 큰 웹 콘텐츠를 전송하면 네트워크 혼잡 문제가 발생할 수 있습니다. 이러한 문제점을 해결하기 위해 개발된 것이 CDN입니다.

<br/>

## 📌 12. 유닛 테스트에 대해 설명해주세요

### 단위(Unit) 테스트

- 모듈(함수/클래스) 단위의 테스트
- 작성 비용이 적게 들고 실행 속도가 빠르다
- 실패했을 때 문제가 생긴 부분을 비교적 정확하게 파악할 수 있다.

<br/>

## 📌 13. 통합 테스트에 대해 설명해주세요

### 통합(Integration) 테스트

- 주로 단위 테스트보다 큰 범위의 테스트를 의미한다.
- 개별 모듈(함수/클래스)들이 연결되어 제대로 상호작용하는지를 테스트한다.
- 단위 테스트에 비해 실패 시 문제가 생긴 부분을 정확히 파악하기가 어렵다.

<br/>

## 📌 14. E2E 테스트에 대해 설명해주세요

### E2E(End to End) 테스트

- 실제 사용자가 사용하는 것과 같은 조건에서 전체 시스템을 테스트한다.
- 단위/통합 테스트에 비해 작성이 어렵고 실행 속도가 비교적 느리다
- API 서버, DB 등의 외부 서비스들을 모두 사용하여 시스템을 테스트한다.

<br/>

## 📌 15. business logic에 대해 설명해주세요

비즈니스 로직은 컴퓨터 프로그램에서 실세계의 규칙에 따라 데이터를 생성,표시,저장,변경하는 부분을 일컫는다.

이 용어는 특히 데이터베이스, 표시장치 등 프로그램의 다른 부분과 대조되는 개념으로 쓰인다.

비즈니스 로직(도메인 로직/애플리케이션 로직)이란 프로그램의 핵심 로직을 뜻합니다.

어떻게 데이터가 생성되고 저장되고 수정되는지를 정희한 것이 비즈니스 로직이라고 할 수 있습니다.

예를 들어 쇼핑물에서 장바구니에 있는 결제 예정 금액이 물품이 추가됨에 따라 수정되는 로직이 바로 비즈니스 로직입니다.

<br/>

## 📌 16. snippet에 대해 설명해주세요

스니펫은 재사용 가능한 소스 코드, 기계어, 텍스트의 작은 부분을 일컫는 프로그래밍 용어이다.

사용자가 루틴 편집 조작 중 반복 타이핑을 회피할 수 있게 도와준다.

스니펫은 작은 조각을 뜻한다.

요즘 활용되는 웬만한 코드편집기, IDE 등은 code snippet 단위로 '템플릿'을 만들어 써먹을 수 있게 되어있다.

지정한 접두어를 입력하면 템플릿이 입력되는 식이다.

<br/>

## 📌 17. 웹팩의 개념과 등장한 이유, 사용 시 이점에 대해 설명해주세요

웹팩이란 최신 프론트엔드 프레임워크에서 가장 많이 사용되는 모듈 번들러입니다.

모듈 번들러란 웹 애플리케이션을 구성하는 자원을 모두 각각의 모듈로 보고 이를 조합해서 병합된 하나의 결과물을 만드는 도구를 의미합니다.

웹 사이트의 경험을 향상시키기위한 많은 노력들이 있었습니다.

그 중 대표적인 노력이 브라우저에서 서버로 요청하는 파일 숫자를 줄이는 것입니다.

이를 위해 웹 테스크 매니저를 이용해 파일들을 압축하고 병합하는 작업들을 진행했습니다.

뿐만 아니라 초기 페이지 로딩 속도를 높이기 위해 나중에 필요한 자원들은 나중에 요청하는 레이지 로딩이 등장했습니다.

웹팩은 기본적으로 필요한 자원은 미리 로딩하는게 아니라 그때 그때 요청하자는 철학을 갖고 있습니다.

웹팩을 통해 모듈을 번들링하면, 해당 파일 들을 하나로 묶기 떄문에 적은 HTTP 요청으로도 번들링 된 파일을 불러올 수 있습니다.

<br/>

## 📌 18. 모듈 번들링이란 무엇인가요?

웹 애플리케이션을 구성하는 몇십, 몇백개의 자원들을 하나의 파일로 병합 및 압축 해주는 동작을 모듈 번들링이라고 합니다.

파일들의 연관된 관계를 파악하여 파일들을 하나의 파일로 압축시켜주는 과정을 번들링 과정이라 합니다.

<br/>

## 📌 19. 바벨에 대해 설명해주세요

바벨은 자바스크립트에서 지원하는 최신 문법(ES6, ES7, ES8, ES9...)들을 최대한 많은 브라우저 한경에서 호환이 가능하도록 변환해주는(트랜스파일링해주는) 언어입니다.

<br/>

### 트랜스파일이란?

한 언어로 작서왼 소스 코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환하는 것을 말합니다.

ex)

```
es6 => es5
c++ => c
coffescript => javascript
```

<br/>

## 📌 20. 웹팩의 주요 속성 4가지가 무엇이라 생각하시나요?

### 1. entry

entry 속성은웹펙에서 웹 자원을 변환하기 위해 필요한 최초 진입점이자 자바스크립트 파일 경로입니다.

`빌드를 할 대상 파일의 위치`라고 볼 수 있습니다.

```
// webpack.config.js
module.exports = {
  entry: "./src/index.js",
};
```

<br/>

### 2. output

output 속성은 웹팩을 돌리고 난 결과물의 파일 경로를 의미합니다.

```
// webpack.config.js
var path = require("path");

module.exports = {
  output: {
    filename: "bundle.js",
    path: path.resolve(__dirname, "./dist"),
  },
};
```

entry 속성과는 다르게 객체 형태로 옵션들을 추가해야 합니다.

최소한 filename은 지정해줘야 하며 일반적으로 path 속성을 같이 정의합니다.

- filename 속성은 웹팩으로 빌드(번들링)한 파일의 이름을 의미합니다.
- path 속성은 해당 파일의 경로를 의미합니다.
- path 속성에서 사용된 path.resolve()코드는 인자로 넘어온 경로들을 조합하여 유효한 파일 경로를 만들어주는 Node.js API입니다.

따라서 dist 라는 폴더 안에 있는 bundle.js 라는 파일 이름으로 엔트리에 들어온 파일을 빌드(번들링)하여 결과물로 가져올 것입니다.

<br/>

### 3. loader

로더는 웹팩이 웹 애플리케이션을 해석할 때 자바스크립트 파일이 아닌 웹 자원들을 빌드 시에, 자바스크립트의 output 파일에 포함될 수 있도록 도와주는 속성입니다.

엔트리나 아웃풋 속성과는 다르게 module이라는 이름을 사용합니다.

```
// webpack.config.js
module.exports = {
  module: {
    rules: [],
  },
};
```

<br/>

### 4. plugin

플러그인은 웹팩의 기본적인 동작에 추가적인 기능을 제공하는 속성입니다.

로더랑 비교하면 로더는 파일을 해석하고 변환하는 과정에 관여하는 반면, 플러그인은 해당 결과물의 형태를 바꾸는 역할을 한다고 보면 됩니다.

```
// webpack.config.js
module.exports = {
  plugins: [],
};
```

플러그 인 배열에는 생성자 함수로 생성한 객체 인스턴스만 추가될 수 있습니다.

```
// webpack.config.js
var webpack = require("webpack");
var HtmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  plugins: [new HtmlWebpackPlugin(), new webpack.ProgressPlugin()],
};
```

<br/>

출처 : https://github.com/junh0328/prepare_frontend_interview/blob/main/cs.md#CI-CD
