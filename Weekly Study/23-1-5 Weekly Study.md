# 23년 1월 다섯째주 Weekly Study

<br>

### 📜 목차

1. 클로저에 대해서 설명해주세요
2. 생성자 함수와 클래스는 어떤 차이가 있나요?
3. 브라우저의 렌더링 과정에 대해 설명해보세요 🔥
4. 브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요? 🔥
5. <script></script> 태그를 <body></body> 태그 밑에 둬야하는 이유가 있을까요?
6. 스프레드 문법에 대해 설명해주세요
7. DOM에 대해 설명해주세요
8. e.preventDefault 와 e.stopPropagation의 차이점에 대해 설명해주세요
9. 이벤트 전파(propagation)에 대해서 알고 있나요?
10. 이벤트 위임(delegation)에 대해서 알고있나요? 🔥
11. 동기와 비동기의 차이점에 대해서 설명해줄 수 있나요? 🔥
12. 이벤트 루프와 태스크 큐에 대해서 알고 있나요? 🔥🔥
13. 마이크로태스크 큐에 대해서 알고 있나요? 🔥
14. 태스크 큐와 마이크로태스크 큐 중 어떤 것이 먼저 실행되나요? 🔥
15. Ajax를 사용하면 기존 방식과 어떤 차이가 있을까요?
16. JSON 이 뭔가요?
17. XMLHttpRequest와 fetch 메서드의 차이는 무엇이라고 생각하시나요?
18. REST API에 대해 설명해주세요
19. HTTP 상태 코드를 아는대로 말해주세요 🔥
20. HTTP 요청 메서드에 대해서 아는대로 얘기해보세요

<br>

## 📌 1. 클로저에 대해서 설명해주세요.

클로저는 두 가지로 설명할 수 있다.

- 자신이 선언될 당시의 환경을 기억하는 함수.
- 함수와 그 함수가 선언된 렉시컬 환경의 조합.

해당 함수의 생명 주기가 종료되더라도 함수의 반환된 값이 변수에 의해 아직 참조되고 있다면 생명 주기가 종료되더라도 렉시컬 환경에 남아 참조가 가능하다.

클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.

다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.

```javascript
<script>
     function foo() {
       const x = 1;
       const y = 2;

       // 클로저
       // 중첩 함수 bar는 외부 함수보다 더 오래 유지되며 상위 스코프의 식별자를 참조한다.
       function bar() {
         debugger;
         console.log(x);
       }
       return bar;
     }

     const bar = foo();
     bar();
   </script>
```

<br>

## 📌 2. 생성자 함수와 클래스는 어떤 차이가 있나요?

1. 클래스를 new 연산자 없이 호출하면 에러가 발생한다. 하지만, 생성자 함수는 일반 함수로 호출된다.

```javascript
const me = new Person("soohyun");
```

2. 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 생성자 함수는 해당 키워드를 제공하지 않는다.

3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만, 함수 선언문으로 작성된 클래스는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.

4. 클래스 내의 모든 코드에는 암묵적으로 strict mode가 저장되어 실행되며 strict mode를 해제할 수 없다. 반면, 생성자 함수는 암묵적으로 strict mode가 지정되지 않는다.

5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]] 값이 false인 열거가 되지 않는 값이다.

<br>

## 📌 3. 브라우저의 렌더링 과정에 대해 설명해보세요 🔥

1. 클라이언트에서 불러오고 싶은 파일을 서버에 요청한다.

- 주소창에 직접 입력하거나, 클릭을 통해 해당 웹 페이지에 접근한다.
- 클라이언트에서 요청한 URI를 DNS를 통해 IP 주소로 변환하고, 해당 IP를 가진 서버에 GET 요청을 보내게 된다.

2. 서버에서 응답 받은 HTML 데이터를 파싱한다. (바이트 > 문자 > 토큰 > 노드 > DOM)

- 서버에 존재하던 HTML 파일이 브라우저의 요청에 의해 응답된다.
- 이때 서버는 브라우저가 요청한 HTML 파일을 읽어 들여 메모리에 저장한 다음 메모리에 저장된 바이트(2진수)를 인터넷을 경유하여 응답한다.
- 브라우저는 서버가 응답한 HTML 문서를 바이트(2진수) 형태로 응답받는다.
- 따라서 응답된 바이트 형태의 HTML 문서를 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환한다.
- 문자열로 변환된 HTML 문서를 읽어 들여 문법적 의미를 갖는 코드의 최소 단위인 토큰들로 분해한다.
- 각 토큰들을 객체로 변환하여 노드들을 생성한다. 토큰의 내용에 따라 (1) 문서 노드 (2) 요소 노드 (3) 어트리뷰트 노드 (4) 텍스트 노드가 생성된다.

3. HTML 마크업을 바탕으로 DOM 트리를 생성한다.

- HTML 문서는 HTML 요소들의 집합으로 이루어지며, HTML 요소는 중첩 관계를 갖는다.
- 이때 HTML 요소 간에는 중첩 관계에 의해 부모(부모자식)관계가 형성된다.
- 이러한 HTML 요소 간의 부자 관계를 반영하여 모든 노드들을 트리 자료구조로 구성한다.
- 이 노드들로 구성된 트리 자료구조를 DOM 이라고 한다.

4. CSS 마크업을 바탕으로 CSSOM 트리를 생성한다. (바이트 > 문자 > 토큰 > 노드 > CSSOM)

- HTML 데이터와 마찬가지로 파싱하여 CSSOM 트리 구조로 나타낸다.

5. DOM트리와 CSSOM트리를 결합하여 렌더 트리를 형성한다.

- 렌더링 엔진에 의해 문서의 처음부터 끝까지 해석이 완료되어 `DOM트리`와 `CSSOM트리`가 완성된다면, 이 둘을 바탕으로 렌더 트리를 생성한다.

6. 렌더 트리에서 레이아웃을 실행한다.

- 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)를 계산한다.

7. 개별 노드를 화면에 페인트한다.

- 이후, 레이아웃을 바탕으로 브라우저 화면에 픽셀을 렌더링하는 페인팅처리에 입력되면 렌더링이 완료되게 된다.

<br>

## 📌 4. 브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요? 🔥

1. HTML/CSS 파싱 과정과 마찬가지로 렌더링 엔진은 HTML을 한 줄씩 순차적으로 파싱하며 DOM을 생성해 나아가다가 자바스크립트 파일을 로드하는 `<script>` 태그나 자바스크립트 코드를 콘텐츠로 담은 `<script>` 태그를 만나면 DOM 생성을 일시 중지한다.

2. 그리고 `<script>` 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 서버에 요청하여 로드한 자바스크립트 파일이나 <script> 태그 내의 자바스크립트 코드를 파싱하기 위해 `자바스크립트 엔진`에 제어권을 넘긴다. 이후 자바스크립트 파싱과 실행이 종료 되면 `렌더링 엔진`으로 다시 제어권을 넘겨 HTML 파싱이 중단된 지점부터 다시 HTML 파싱을 시작하여 DOM 생성을 재개한다.

3. 자바스크립트 파싱과 실행은 `브라우저 렌더링 엔진`이 아닌 `자바스크립트 엔진`이 처리한다. `자바스크립트 엔진`은 자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 저수준 언어로 변환하고 실행하는 역할을 한다.

4. `자바스크립트 엔진`은 자바스크립트를 해석하여 `AST(Abstract Syntax Tree 추상 구문 트리)`를 생성한다. 그리고 AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행한다.

5. 리플로우와 리페인트

- 만약 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우 DOM이나 CSSOM이 변경된다.
- 이때 변경된 DOM이나 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링한다. 이를 `리플로우` `리페인트`라 한다.

<br>

### 📌 3 ~ 4번 질문 종합

1. 사용자가 웹브라우저에 접속함.
2. 웹브라우저는 DNS 에게 host 의 ip 주소를 받아옴
3. ip 주소에 있는 서버를 찾아가
4. 서버와 브라우저는 3 Way-Handshake 를 실행함
5. 이후 브라우저는 서버에게 데이터( HTML, CSS, JS, 이미지, 폰트 파일 등 렌더링에 필요한 리소스)를 요청함. **(HTTP Request)**
6. 서버는 브라우저에게 데이터를 보내줌 **(HTTP Response)**
7. 브라우저는 서버로부터 받은 데이터를 해석함 (Parsing)
8. 브라우저의 렌더링 엔진은 HTML을 파싱하여 DOM Tree 를 생성함.
9. 이때, 렌더링 엔진이 style 태그를 만난다면 HTML 파싱을 중지하고 CSS 파싱 작업을 시작하여 CSSOM Tree를 생성.
10. CSS파싱을 마치면 HTML 파싱이 중단된 시점부터 다시 파싱 시작
11. 그러다가 scirpt 태그를 만나면 파싱을 중지하고 자바스크립트 엔진에게 제어 권한을 넘김
12. JS엔진은 코드를 해석하고 추상구문 Tree 인 AST(Abstract Syntax Tree)를 생성하고 실행한다.
13. 중단했던 HTML 파싱을 완료함.
14. DOM Tree + CSSOM Tree = Render Tree // **여기까지가 Construction**
15. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다.
16. UI Backend가 Render Tree의 노드들을 돌면서 UI 를 그림
17. 노드들의 레이어를 순서대로 구성하는 **Composition 단계** **layout~composition = Operation**
18. 최종적으로 사용자에게 화면 출력

<br>

### 추가 질문

<br>

### ✔️ 파싱이란?

파싱(구문 분석)은 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰 단위로 분해하고, 토큰의 문법적 의미와 구조를 반영하여 트리 구조의 자료 구조인 파스 트리를 생성하는 일련의 과정을 말한다.

### ✔️ 렌더링

렌더링은 HTML,CSS,JS로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 말한다.

### ✔️ 리소스

HTTP 요청 대상을 "리소스"라고 부른다. 각 리소스는 리소스 식별을 위해 HTTP 전체에서 사용되는 URI에 의해 식별된다.

### ✔️ DNS

DNS(Domain Name System)는 인터넷과 연결된 리소스를 위한 계층적이고 분산된 명명 시스템이다. DNS는 도메인 이름 목록과 연결된 리소스(ex. IP주소)를 유지 관리한다.

### ✔️ 리플로우

DOM 요소의 기하학적 속성이 변경될때, 브라우저 사이즈가 변할때, 스타일시트가 로딩되었을 때 발생하는 변화들을 다시 계산해주는 작업을 뜻한다.

### ✔️ 리페인트

변경된 요소를 실제로 화면에 그려주는 작업을 리페인트라고 한다. <br>
리플로우가 발생하면 필연적으로 리페인트가 실행된다.

<br>

## 5. <script></script> 태그를 <body></body> 태그 밑에 둬야하는 이유가 있을까요?

간단한 자바스크립트 코드는 문제가 생기지 않을 것이지만, 무거운 자바스크립트 코드를 `<body>`태그 위에 두게 되면, 이 코드들을 불러오고 실행하는 동안 `<script>`태그의 밑에 위치한 `<body>`태그들이 로딩되지 못할 것이다.

이말인즉슨 브라우저가 렌더링되는 과정에 방해를 받게 되고 사용자는 완성되지 못한 화면을 경험하게 되어 사용자 경험 측면에서 부정적인 영향을 받게 된다.

`<script>`태그를 `<body>`태그 하단에 위치 시키면 무거운 자바스크립트 코드를 가지고 있더라도 사용자는 HTML과 CSS가 완성된 화면을 경험할 수 있게된다.

또 다른 이유는 DOM 구조가 완료되지 않은 시점에서 DOM에 접근하게 되는 경우가 발생하여 정상적인 코드 동작이 이뤄지지 않는 경우들이 생길 수도 있다.

`<script>` 태그를 변경하는 것 이외에 defer과 async 속성을 사용할 수도 있다.

defer과 async 속성을 사용하면 브라우저는 html 파싱을 멈추지 않고 스크립트 로딩과 파싱을 동시에 진행하게된다. 즉, 스크립트 로딩이 비동기적으로 수행된다.

defer과 async 속성의 차이는 스크립트의 실행 시점이다.

defer는 스크립트 로딩이 완료되어도 실행되지 않고 html 문서가 모두 파싱될때가지 기다렸다가 파싱이 완료되면 그때 실행된다.

반면, async는 html 문서의 파싱 완료 여부와 상관없이 스크립트가 로딩되면 바로 스크립트를 실행한다.

## 📚 참고

[prepare frontend interview](https://github.com/junh0328/prepare_frontend_interview/blob/main/js.md)
[브라우저 렌더링 - 리플로우(reflow) 와 리페인트(repaint)](https://kwangsunny.tistory.com/42)
