# 23년 1월 다섯째주 Weekly Study

<br>

### 📜 목차

1. 클로저에 대해서 설명해주세요
2. 생성자 함수와 클래스는 어떤 차이가 있나요?
3. 브라우저의 렌더링 과정에 대해 설명해보세요 🔥
4. 브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요? 🔥
5. <script></script> 태그를 <body></body> 태그 밑에 둬야하는 이유가 있을까요?
6. 스프레드 문법에 대해 설명해주세요
7. DOM에 대해 설명해주세요
8. e.preventDefault 와 e.stopPropagation의 차이점에 대해 설명해주세요
9. 이벤트 전파(propagation)에 대해서 알고 있나요?
10. 이벤트 위임(delegation)에 대해서 알고있나요? 🔥
11. 동기와 비동기의 차이점에 대해서 설명해줄 수 있나요? 🔥
12. 이벤트 루프와 태스크 큐에 대해서 알고 있나요? 🔥🔥
13. 마이크로태스크 큐에 대해서 알고 있나요? 🔥
14. 태스크 큐와 마이크로태스크 큐 중 어떤 것이 먼저 실행되나요? 🔥
15. Ajax를 사용하면 기존 방식과 어떤 차이가 있을까요?
16. JSON 이 뭔가요?
17. XMLHttpRequest와 fetch 메서드의 차이는 무엇이라고 생각하시나요?
18. REST API에 대해 설명해주세요
19. HTTP 상태 코드를 아는대로 말해주세요 🔥
20. HTTP 요청 메서드에 대해서 아는대로 말해주세요

<br>

## 📌 1. 클로저에 대해서 설명해주세요.

클로저는 두 가지로 설명할 수 있다.

- 자신이 선언될 당시의 환경을 기억하는 함수.
- 함수와 그 함수가 선언된 렉시컬 환경의 조합.

해당 함수의 생명 주기가 종료되더라도 함수의 반환된 값이 변수에 의해 아직 참조되고 있다면 생명 주기가 종료되더라도 렉시컬 환경에 남아 참조가 가능하다.

클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.

다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.

```javascript
<script>
     function foo() {
       const x = 1;
       const y = 2;

       // 클로저
       // 중첩 함수 bar는 외부 함수보다 더 오래 유지되며 상위 스코프의 식별자를 참조한다.
       function bar() {
         debugger;
         console.log(x);
       }
       return bar;
     }

     const bar = foo();
     bar();
   </script>
```

<br>

## 📌 2. 생성자 함수와 클래스는 어떤 차이가 있나요?

1. 클래스를 new 연산자 없이 호출하면 에러가 발생한다. 하지만, 생성자 함수는 일반 함수로 호출된다.

```javascript
const me = new Person("soohyun");
```

2. 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 생성자 함수는 해당 키워드를 제공하지 않는다.

3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만, 함수 선언문으로 작성된 클래스는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.

4. 클래스 내의 모든 코드에는 암묵적으로 strict mode가 저장되어 실행되며 strict mode를 해제할 수 없다. 반면, 생성자 함수는 암묵적으로 strict mode가 지정되지 않는다.

5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]] 값이 false인 열거가 되지 않는 값이다.

<br>

## 📌 3. 브라우저의 렌더링 과정에 대해 설명해보세요 🔥

1. 클라이언트에서 불러오고 싶은 파일을 서버에 요청한다.

- 주소창에 직접 입력하거나, 클릭을 통해 해당 웹 페이지에 접근한다.
- 클라이언트에서 요청한 URI를 DNS를 통해 IP 주소로 변환하고, 해당 IP를 가진 서버에 GET 요청을 보내게 된다.

2. 서버에서 응답 받은 HTML 데이터를 파싱한다. (바이트 > 문자 > 토큰 > 노드 > DOM)

- 서버에 존재하던 HTML 파일이 브라우저의 요청에 의해 응답된다.
- 이때 서버는 브라우저가 요청한 HTML 파일을 읽어 들여 메모리에 저장한 다음 메모리에 저장된 바이트(2진수)를 인터넷을 경유하여 응답한다.
- 브라우저는 서버가 응답한 HTML 문서를 바이트(2진수) 형태로 응답받는다.
- 따라서 응답된 바이트 형태의 HTML 문서를 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환한다.
- 문자열로 변환된 HTML 문서를 읽어 들여 문법적 의미를 갖는 코드의 최소 단위인 토큰들로 분해한다.
- 각 토큰들을 객체로 변환하여 노드들을 생성한다. 토큰의 내용에 따라 (1) 문서 노드 (2) 요소 노드 (3) 어트리뷰트 노드 (4) 텍스트 노드가 생성된다.

3. HTML 마크업을 바탕으로 DOM 트리를 생성한다.

- HTML 문서는 HTML 요소들의 집합으로 이루어지며, HTML 요소는 중첩 관계를 갖는다.
- 이때 HTML 요소 간에는 중첩 관계에 의해 부모(부모자식)관계가 형성된다.
- 이러한 HTML 요소 간의 부자 관계를 반영하여 모든 노드들을 트리 자료구조로 구성한다.
- 이 노드들로 구성된 트리 자료구조를 DOM 이라고 한다.

4. CSS 마크업을 바탕으로 CSSOM 트리를 생성한다. (바이트 > 문자 > 토큰 > 노드 > CSSOM)

- HTML 데이터와 마찬가지로 파싱하여 CSSOM 트리 구조로 나타낸다.

5. DOM트리와 CSSOM트리를 결합하여 렌더 트리를 형성한다.

- 렌더링 엔진에 의해 문서의 처음부터 끝까지 해석이 완료되어 `DOM트리`와 `CSSOM트리`가 완성된다면, 이 둘을 바탕으로 렌더 트리를 생성한다.

6. 렌더 트리에서 레이아웃을 실행한다.

- 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)를 계산한다.

7. 개별 노드를 화면에 페인트한다.

- 이후, 레이아웃을 바탕으로 브라우저 화면에 픽셀을 렌더링하는 페인팅처리에 입력되면 렌더링이 완료되게 된다.

<br>

## 📌 4. 브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요? 🔥

1. HTML/CSS 파싱 과정과 마찬가지로 렌더링 엔진은 HTML을 한 줄씩 순차적으로 파싱하며 DOM을 생성해 나아가다가 자바스크립트 파일을 로드하는 `<script>` 태그나 자바스크립트 코드를 콘텐츠로 담은 `<script>` 태그를 만나면 DOM 생성을 일시 중지한다.

2. 그리고 `<script>` 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 서버에 요청하여 로드한 자바스크립트 파일이나 <script> 태그 내의 자바스크립트 코드를 파싱하기 위해 `자바스크립트 엔진`에 제어권을 넘긴다. 이후 자바스크립트 파싱과 실행이 종료 되면 `렌더링 엔진`으로 다시 제어권을 넘겨 HTML 파싱이 중단된 지점부터 다시 HTML 파싱을 시작하여 DOM 생성을 재개한다.

3. 자바스크립트 파싱과 실행은 `브라우저 렌더링 엔진`이 아닌 `자바스크립트 엔진`이 처리한다. `자바스크립트 엔진`은 자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 저수준 언어로 변환하고 실행하는 역할을 한다.

4. `자바스크립트 엔진`은 자바스크립트를 해석하여 `AST(Abstract Syntax Tree 추상 구문 트리)`를 생성한다. 그리고 AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행한다.

5. 리플로우와 리페인트

- 만약 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우 DOM이나 CSSOM이 변경된다.
- 이때 변경된 DOM이나 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링한다. 이를 `리플로우` `리페인트`라 한다.

<br>

### 📌 3 ~ 4번 질문 종합

1. 사용자가 웹브라우저에 접속함.
2. 웹브라우저는 DNS 에게 host 의 ip 주소를 받아옴
3. ip 주소에 있는 서버를 찾아가
4. 서버와 브라우저는 3 Way-Handshake 를 실행함
5. 이후 브라우저는 서버에게 데이터( HTML, CSS, JS, 이미지, 폰트 파일 등 렌더링에 필요한 리소스)를 요청함. **(HTTP Request)**
6. 서버는 브라우저에게 데이터를 보내줌 **(HTTP Response)**
7. 브라우저는 서버로부터 받은 데이터를 해석함 (Parsing)
8. 브라우저의 렌더링 엔진은 HTML을 파싱하여 DOM Tree 를 생성함.
9. 이때, 렌더링 엔진이 style 태그를 만난다면 HTML 파싱을 중지하고 CSS 파싱 작업을 시작하여 CSSOM Tree를 생성.
10. CSS파싱을 마치면 HTML 파싱이 중단된 시점부터 다시 파싱 시작
11. 그러다가 scirpt 태그를 만나면 파싱을 중지하고 자바스크립트 엔진에게 제어 권한을 넘김
12. JS엔진은 코드를 해석하고 추상구문 Tree 인 AST(Abstract Syntax Tree)를 생성하고 실행한다.
13. 중단했던 HTML 파싱을 완료함.
14. DOM Tree + CSSOM Tree = Render Tree // **여기까지가 Construction**
15. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다.
16. UI Backend가 Render Tree의 노드들을 돌면서 UI 를 그림
17. 노드들의 레이어를 순서대로 구성하는 **Composition 단계** **layout~composition = Operation**
18. 최종적으로 사용자에게 화면 출력

<br>

### 추가 질문

<br>

### ✔️ 파싱

파싱(구문 분석)은 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰 단위로 분해하고, 토큰의 문법적 의미와 구조를 반영하여 트리 구조의 자료 구조인 파스 트리를 생성하는 일련의 과정을 말한다.

### ✔️ 렌더링

렌더링은 HTML,CSS,JS로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 말한다.

### ✔️ 리소스

HTTP 요청 대상을 "리소스"라고 부른다. 각 리소스는 리소스 식별을 위해 HTTP 전체에서 사용되는 URI에 의해 식별된다.

### ✔️ DNS

DNS(Domain Name System)는 인터넷과 연결된 리소스를 위한 계층적이고 분산된 명명 시스템이다. DNS는 도메인 이름 목록과 연결된 리소스(ex. IP주소)를 유지 관리한다.

### ✔️ 리플로우

DOM 요소의 기하학적 속성이 변경될때, 브라우저 사이즈가 변할때, 스타일시트가 로딩되었을 때 발생하는 변화들을 다시 계산해주는 작업을 뜻한다.

### ✔️ 리페인트

변경된 요소를 실제로 화면에 그려주는 작업을 리페인트라고 한다. <br>
리플로우가 발생하면 필연적으로 리페인트가 실행된다.

<br>

## 5. <script></script> 태그를 <body></body> 태그 밑에 둬야하는 이유가 있을까요?

간단한 자바스크립트 코드는 문제가 생기지 않을 것이지만, 무거운 자바스크립트 코드를 `<body>`태그 위에 두게 되면, 이 코드들을 불러오고 실행하는 동안 `<script>`태그의 밑에 위치한 `<body>`태그들이 로딩되지 못할 것이다.

이말인즉슨 브라우저가 렌더링되는 과정에 방해를 받게 되고 사용자는 완성되지 못한 화면을 경험하게 되어 사용자 경험 측면에서 부정적인 영향을 받게 된다.

`<script>`태그를 `<body>`태그 하단에 위치 시키면 무거운 자바스크립트 코드를 가지고 있더라도 사용자는 HTML과 CSS가 완성된 화면을 경험할 수 있게된다.

또 다른 이유는 DOM 구조가 완료되지 않은 시점에서 DOM에 접근하게 되는 경우가 발생하여 정상적인 코드 동작이 이뤄지지 않는 경우들이 생길 수도 있다.

`<script>` 태그를 변경하는 것 이외에 defer과 async 속성을 사용할 수도 있다.

defer과 async 속성을 사용하면 브라우저는 html 파싱을 멈추지 않고 스크립트 로딩과 파싱을 동시에 진행하게된다. 즉, 스크립트 로딩이 비동기적으로 수행된다.

defer과 async 속성의 차이는 스크립트의 실행 시점이다.

defer는 스크립트 로딩이 완료되어도 실행되지 않고 html 문서가 모두 파싱될때가지 기다렸다가 파싱이 완료되면 그때 실행된다.

반면, async는 html 문서의 파싱 완료 여부와 상관없이 스크립트가 로딩되면 바로 스크립트를 실행한다.

<br>

## 6. 스프레드 문법에 대해 설명해주세요

ES6에서 도입된 스프레드 문법은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다.

❗값을 만드는 것이 아닌 값들의 목록을 만든는 것이므로 변수에 할당은 불가하다. 변수에는 값만 할당 가능하기 때문이다.

<br>

스프레드 문법을 적용할 수 있는 대상은 다음과 같다.

1. Array
2. String
3. Map
4. Set
5. DOM 컬렉션
6. arguments와 같이 for of 문으로 순회할 수 있는 이터러블

<br>

## 7. DOM에 대해 설명해주세요

DOM은 HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API, 즉 프로퍼티와 메서드를 제공하는 트리 자료구조이다.

DOM을 구성하는 것은 다음과 같다.

HTML 요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 요소 노드 객체로 변환된다.
이때 HTML 요소 어트리뷰트는 어트리뷰트 노드로, HTML 요소의 텍스트 콘텐츠는 텍스트 노드로 변환된다.
DOM은 노드 객체의 계층적인 구조로 구성된다.

노드 객체는 종류가 있고 상속 구조를 갖는다.

노드 객체는 총 12개의 노드 타입이 있다. 이 중에서 가장 중요한 노드 타입은 다음의 4가지이다.

1. 문서 노드
   DOM 트리의 최상위에 존재하는 루트 노드로서 document 객체를 가리킨다.
   HTML 문서당 document 객체는 유일하다.

2. 요소 노드
   `<html>` `<head>` `<body>` 등등...
   HTML 요소를 가리키는 객체이다. 문서의 구조를 표현하고 있다.

3. 어트리뷰트 노드
   `charset="UTF` `id='name'` 등등...
   HTML 요소의 어트리뷰트를가리키는 객체이다.

4. 텍스트 노드

HTML 요소와 텍스트를 가리키는 객체이다. 요소 노드가 문서의 구조를 표현하나면 텍스트 노드는 문서의 정보를 표현한다.

<br>

## 8. e.preventDefault 와 e.stopPropagation의 차이점에 대해 설명해주세요

e.preventDefault 메서드는 요소 태그의 기본 동작을 중단합니다.
e.stopPropagation 메서드는 이벤트 전파를 중지시킵니다. 이벤트 객체의 경우 상위 태그에도 같은 이벤트가 존재한다면 상위 태그의 해당 콜백함수를 호출하는 특징이 있습니다.

<br>

## 9. 이벤트 전파(propagation)에 대해서 알고 있나요?

DOM 트리상에 존재하는 모든 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파됩니다. 이를 이벤트 전파라고 합니다.

사용자의 다양한 입력을 통해 동적으로 생성되는 이벤트 객체는 이벤트를 발생시킨 타깃을 중심으로 DOM 트리를 통해 전파됩니다.

전파되는 방향에 따라 3단계로 구분할 수 있습니다.

- 캡쳐링 단계 : 이벤트가 상위 요소에서 하위 요소 방향으로 전파
- 타깃 단계 : 이벤트가 이벤트 타깃에 도달
- 버블링 단계 : 이벤트가 하위 요소에서 상위 요소 방향으로 전파

브라우저는 기본적으로 버블링 단계에서 이벤트를 캐치합니다.
`addEventListener` 메서드의 세번째 인수로 옵션인 [, useCapture] 자리에 true 를 넣어주면 캡쳐링 단계에서도 이벤트 객체를 캐치할 수 있다.
기본 값은 false로 버블링 단계에서 캐치를 한다.

<br>

## 10. 이벤트 위임(delegation)에 대해서 알고있나요? 🔥

캡쳐링과 버블링을 이용한 것으로, 여러 엘리먼트마다 각각 이벤트 핸들러를 할당하지 않고, 공통되는 부모에 이벤트 핸들러를 할당하여 이벤트를 관리하는 방식.

연속되는 태그에 대해서 공통적으로 이벤트를 줘야할 때 우리가 이벤트 핸들러를 바인딩할 요소의 부모 요소에게 이를 위임하여 이벤트를 진행하는 것을 말합니다.

<br>

## 11. 동기와 비동기의 차이점에 대해서 설명해줄 수 있나요? 🔥

1. 현재 실행중인 태스크가 종료될 때까지 다음에 실행될 태스크가 대기하는 방식을 동기처리 방식이라한다.

2. 현재 실행중인 태스크가 종료되지 않은상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기 처리라고 한다.

3. 대표적으로 타이머 함수인 `1. setTimeout/setInterval` `2. HTTP 요청` `이벤트 핸들러`는 비동기 처리 방식으로 동작한다.

<br>

## 12. 이벤트 루프와 태스크 큐에 대해서 알고 있나요?

이벤트 루프란 자바스크립트 엔진이 아닌, 구동하는 환경(브라우저, 노드)에서 가지고 있는 장치이다. <br>
콜 스택과 태스크 큐(=콜백 큐)를 감시하며, 콜 스택이 비어있을 경우에 태스크 큐에서 태스크(=콜백함수)를 가져와 콜 스택에 넣어 실행시키는 기능을 한다.

이벤트 루프에는 window event loop, worker event loop, worklet event loop 세 가지 종류가 있다.

태스크 큐는 `setTimeout`이나 `setInterval` 같은 비동기 함수의 콜백 함수, 이벤트 핸들러가 일시적으로 보관되는 영역이다.

<br>

## 13. 마이크로태스크 큐에 대해서 알고 있나요? 🔥

마이크로태스크 큐는 태스크큐와 별도의 큐로 후속 처리 메서드의 콜백 함수가 일시 저장된다.

그 외의 비동기 함수 setTimeout/setInterval 이나 HTTP 요청, 이벤트 핸들러의 콜백 함수나 이벤트 핸들러는 테스크 큐에 일시 저장된다.

콜백 함수나 이벤트 핸들러를 일시 저장한다는 점에서 태스크 큐와 동일하지만 마이크로테스크 큐는 태스크 큐보다 우선순위가 ㄴ높다.

<br>

## 14. 태스크 큐와 마이크로태스크 큐 중 어떤 것이 먼저 실행되나요? 🔥

이벤트 루프는 마이크로태스크 큐의 모든 태스크들을 처리한 다음, 테스크 큐의 테스크들을 처리한다. <br>
따라서, 마이크로태스크 큐가 먼저 실행된다.
<br>

## 15. Ajax를 사용하면 기존 방식과 어떤 차이가 있을까요?

1. 변경할 부분을 갱신하는데 필요한 데이터만 서버로부터 전송받기 때문에 불필요한 데이터 통신이 발생하지 않는다.
2. 변경할 필요가 없는 부분은 다시 렌더링하지 않는다. 따라서 화면이 순간적으로 깜박이는 현상이 발생하지 않는다.
3. 클라이언트와 서버와의 통신이 비동기 방식으로 동작하기 때문에 서버에게 요청을 보낸 이후 블로킹이 발생하지 않는다.

<br>

## 16. JSON 이 뭔가요?

JavaScript Object Notation의 약자입니다. JSON은 클라이언트와 서버 간의 HTTP 통신을 우한 텍스트 데이터 포맷입니다.

자바스크립트에 종속되지 않는 언어 독립형 데이터 포맷으로, 대부분의 프로그래밍 언어에서 사용할 수 있습니다.

<br>

## 17. XMLHttpRequest와 fetch 메서드의 차이는 무엇이라고 생각하시나요?

fetch 메서드 또한 XMLHttpRequest 처럼 Ajax 통신을 위해 사용된다.

하지만, fetch 메서드는 Promise를 기반으로 구성되어 있어서 더 간편하게 사용할 수 있다는 차이점이 있습니다.

Promise의 후속 처리 메서드 .then() .catch() .finally() 등을 사용하여 코드를 작성할 수 있습니다.

<br>

## 18. REST API에 대해 설명해주세요

REST는 HTTP의 장점을 최대한 활용할 수 있는 아키텍처로서, HTTP 프로토콜을 의도에 맞게 디자인하다록 유도합니다.

즉, REST는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍쳐고, REST API는 REST를 기반으로 서비스 API를 구현한 것을 의미한다.

REST의 기본 원칙을 성실히 지킨 서비스 디자인을 `RESTful`이라고 표현한다.

<br>

## 19. HTTP 상태 코드를 아는대로 말해주세요 🔥

### 200

요청이 성공적으로 보내졌음을 의미

### 201

요청이 성공적이였으며 새로운 리소스가 생성되었음을 의미

### 400

잘못된 문법으로 인하여서버가 요청을 이해할 수 없음을 의미

### 401

비인증된 요청임을 의미

### 403

콘텐츠이 접근할권리를 가지고 있지 않음을 의미

### 404

요청받은 리소스를 찾을 수 없음을 의미

### 500

서버가 처리 방법을 모르는 상황을 의미

<br>

## 20. HTTP 요청 메서드에 대해서 아는대로 말해주세요

### GET

모든/특정 리소스 취득

### POST

리소스 생성

### PUT

리소스의 전체 교체

### PATCH

리소스 일부 수정

### DELETE

모든/특정 리소스 삭제

---

## 📚 참고

- [prepare frontend interview](https://github.com/junh0328/prepare_frontend_interview/blob/main/js.md)
- [브라우저 렌더링 - 리플로우(reflow)와 리페인트(repaint)](https://kwangsunny.tistory.com/42)
